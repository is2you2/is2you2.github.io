[
  
  {
    "title": "Blender 파일을 자바스크립트에서 불러오기",
    "url": "/posts/blender-import-mesh-js/",
    "categories": "작업기록, 포털",
    "tags": "pjcone, ionic, javascript, blender, p5js",
    "date": "2024-03-12 18:03:00 +0900",
    





    
    "snippet": "Blender 파일 분석블렌더 파일의 확장자인 *.blend 는 일종의 압축파일처럼 동작한다.블렌더에서 다른 파일로부터 개체 삽입(append)/링크를 사용해봤다면 블렌더 파일 내부에 폴더 구조로 정보가 분류되어있는 것들을 볼 수 있다.그래서 블렌더 파일을 자바 스크립트에서 읽으려면 파일 자체를 읽는다기보단 내부 정보를 읽는 것이 좋을 것이라고 계획하...",
    "content": "Blender 파일 분석블렌더 파일의 확장자인 *.blend 는 일종의 압축파일처럼 동작한다.블렌더에서 다른 파일로부터 개체 삽입(append)/링크를 사용해봤다면 블렌더 파일 내부에 폴더 구조로 정보가 분류되어있는 것들을 볼 수 있다.그래서 블렌더 파일을 자바 스크립트에서 읽으려면 파일 자체를 읽는다기보단 내부 정보를 읽는 것이 좋을 것이라고 계획하고 있었다.정말 운이 좋게도, 구 버전이긴 했으나 누군가 블렌더 파일을 자바스크립트에서 읽을 수 있도록 시도하고 있었고, 이 자체는 최신 버전과 호환되지 않았으나 블렌더 내부 정보만큼은 여전히 제대로 분류하고 있었다.어떤 식으로 정보가 구성되는지 면밀히 분석해서 내가 원하는 정보만 재조합할 수 있다면 실전에서 사용해볼만했다.면 그리기실제로 면 그리기를 구상하면서 그린 낙서.면과 관련된 정보는 각 면의 시작과 끝을 구분하지 않기 때문에 실제로 ldata를 따라가면서 어떤 방식으로 구분할 수 있을지 고민했었다.내가 바라본 면 처리 방식은 다음과 같다.      면 시작점을 지정한다. 다음 점을 확인한다.    이전 점으로부터 현재 점에 도달할 수 없는 경우 새 면으로 간주한다.    이전 점이 면 시작점이 아니면서 면 시작점에 도착할 수 있을 때, 다른 점으로 이동한다면 새 면으로 간주한다.  의외로 정상적으로 면을 그렸다!그리고 면 정보가 이상적으로 구성되지 않았는지 머터리얼 적용시 비정상적으로 동작하고 있었다.노멀이 다르게 잡혔거나 아니면 지오메트리를 구성하는 방식이 내가 예상한 것과는 좀 달랐는지도 싶은데매우 안타까운 부분..짐벌락 문제테스트를 위해 원숭이 수잔을 여럿 배치해두었는데 누가봐도 짐벌락 문제로 예상되는 모양새를 보인다아마 블렌더 좌표축(보통 y, z가 바뀌어있음)에 맞춰 정보를 교차 기입하는 과정에서 결과물이 다르게 보이게 된 것 같다. 이건 나중에 다른 방식으로 접근해서 해결하든가 해야할 듯..어째뜬 이제 동작함이제 포털앱에서 *.blend 파일을 구분하고, 별도 뷰어 없이 열람할 수 있다.아직 메쉬만 볼 수 있는 수준이지만 최소한 이미지가 포함된 머터리얼까지는 구현되어야 볼만하지 않을까 예상하는중."
  },
  
  {
    "title": "작별인사",
    "url": "/posts/farewell-notebook-msi-ps42/",
    "categories": "일상, 중얼중얼",
    "tags": "mumble",
    "date": "2023-12-30 22:40:00 +0900",
    





    
    "snippet": "그 녀석은 가버렸습니다이 포스트는 그저 주인장의 노트북이 죽은 것을 애도하는 글 입니다.이 녀석은 코딩용 노트북임에도 불구하고 주인장의 혹독한 그래픽 및 렌더링 작업을 감당하지 못하고 순식간에 늙어버리며 죽었습니다. 그럼에도 마지막 렌더링은 아름답게 마무리해주었습니다.짧은 애도의 마음을 남깁니다.새 녀석 등장무려 3중박스가 포장된 채로 눈오는 길목을 ...",
    "content": "그 녀석은 가버렸습니다이 포스트는 그저 주인장의 노트북이 죽은 것을 애도하는 글 입니다.이 녀석은 코딩용 노트북임에도 불구하고 주인장의 혹독한 그래픽 및 렌더링 작업을 감당하지 못하고 순식간에 늙어버리며 죽었습니다. 그럼에도 마지막 렌더링은 아름답게 마무리해주었습니다.짧은 애도의 마음을 남깁니다.새 녀석 등장무려 3중박스가 포장된 채로 눈오는 길목을 뚫고 주말에 배송 도착.이전 녀석의 죽음에서 깨달음을 얻어, 무조건 그래픽 카드가 달린 녀석을 쓰기로 생각을 바꿨습니다.저렴하고 가벼운 노트북을 쓰고 싶었는데 더 이상 그런 시도를 할 수는 없을 것 같군요 😢"
  },
  
  {
    "title": "컴퓨터와 핸드폰만으로 버튜버 시작하기",
    "url": "/posts/setup-virtual-broadcasting/",
    "categories": "정보글, 작업환경",
    "tags": "youtube",
    "date": "2023-12-29 21:20:00 +0900",
    





    
    "snippet": "  이 글은 Windows 및 Android 기준으로 설명되어 있습니다.  누구나 쉽게 시작할 수 있는 세상  우리는 아주 훌륭한 세상에 살고 있습니다. 그리고 너무나도 위태로운 세상에 살고 있죠. 개인정보로 사람을 괴롭힐 수 있는 세상에요 😧이미 준비된 세상에 우리를 드러내면서, 우리를 조심스럽게 숨길 수 있는 버츄얼 유튜버를 시작하고 싶다면 이 글...",
    "content": "  이 글은 Windows 및 Android 기준으로 설명되어 있습니다.  누구나 쉽게 시작할 수 있는 세상  우리는 아주 훌륭한 세상에 살고 있습니다. 그리고 너무나도 위태로운 세상에 살고 있죠. 개인정보로 사람을 괴롭힐 수 있는 세상에요 😧이미 준비된 세상에 우리를 드러내면서, 우리를 조심스럽게 숨길 수 있는 버츄얼 유튜버를 시작하고 싶다면 이 글을 따라 진행해보세요.나는 얼굴 인식할 카메라가 없다이런 저런 이유로 지금 사용할 카메라가 없다면 여러분의 안드로이드 핸드폰을 카메라 겸 마이크로 사용하실 수 있습니다. 컴퓨터에는 클라이언트 프로그램을, 핸드폰에는 서버 앱을 설치해주세요. 이 앱을 정상적으로 사용하려면 핸드폰과 컴퓨터가 같은 공유기를 사용하고 있어야 합니다.휴대폰에 보여지는 주소를 컴퓨터에 입력한 후 시작 버튼을 누르면 휴대폰 카메라를 웹캠으로, 휴대폰 마이크를 마이크로 사용할 수 있습니다.나는 가상 캐릭터가 없다3D 모델링을 공부한게 아니라면 자신이 사용할 가상 캐릭터 모델 역시 없겠죠?스팀에서 무료로 받을 수 있는 Vroid Studio를 다운받아 실행합니다.새 캐릭터를 생성한 후, 캐릭터를 구성합니다.오른쪽 위에 있는 메뉴를 통해 캐릭터를 추출합니다. 추출된 캐릭터는 실전에 사용될 파일로, 캐릭터를 따로 저장하려면 왼쪽 위 메뉴에서 저장하기를 눌러야합니다.출력을 위한 상세 조정인데요. 설정을 조정해서 숫자가 작아질수록 컴퓨터가 덜 부담스러워하는 결과물이 생성됩니다. 물론 숫자가 작아질수록 캐릭터가 덜 부드럽거나, 일부 기능이 제한되기도 합니다. 이 부분은 본인 컴퓨터 사양에 맞게 적당히 설정하면 됩니다.VRM0.0 으로 설정하고, 아바타 이름과 제작자 이름을 작성하고 저장합니다.캐릭터 화면 준비하기이번에는 스팀에서 Animaze 프로그램을 설치한 후 실행합니다.처음 실행하면 버전에 따라 대표 샘플 캐릭터가 우리를 마주해줄텐데, 신기하게 구경해주고 왼쪽 메뉴에서 우리가 만든 캐릭터를 불러옵니다.배경 설정에서 초록색 배경을 선택합니다.가상 카메라를 활성화시킵니다.OBS Studio 에서 방송 준비OBS 프로그램을 설치합니다.첫 실행시 띄워지는 마법사를 이용해서 편안하게 방송 설정을 마무리 짓습니다.장면은 소스가 구성된 것을 저장합니다. 소스는 화면에 보여지는 것들을 말해요.소스들에는 이런 것들이 있는데 주로 사용하는 것들은 이렇습니다.  디스플레이 캡쳐: 모니터 화면을 불러옴비디오 캡쳐: 카메라로 찍히는 화상을 불러옴 (가상 캐릭터 화면도 여기에 속함)윈도우 캡쳐: 프로그램 창 하나를 불러옴, 다른 창을 보고있을 때에도 보여짐소스 목록은 레이어처럼 동작하므로, 버튜얼 카메라를 위에 둔 후 녹색 배경에 크로마키 처리를 해야합니다.소스를 먼저 추가한 후, 목록에서 버츄얼 카메라를 선택한 뒤 필터를 누릅니다.효과 필터에 크로마키 효과를 넣고 녹색을 무시하도록 설정합니다.소스를 화면에 배치하고 나면 이제 방송할 기본 준비 끝."
  },
  
  {
    "title": "코드를 최적화하는 방법",
    "url": "/posts/way-to-optimization/",
    "categories": "정보글, 개발",
    "tags": "쉬운설명",
    "date": "2023-12-28 11:56:00 +0900",
    





    
    "snippet": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.  21세기식 역지사지?  개발을 시작하기 전에 글에서 코드 최적화를 진행하는 가장 쉬운 방법으로 컴퓨터가 하는 일을 사람이 한다고 생각하면 된다고 설명했는데 이에 대한 간단한 예시를 보여드리고자 합니다.갑자기 분위기 K-메타버스설명은 역시 눈에 보이는 데이터가 있는 편이 이해에 편하겠죠...",
    "content": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.  21세기식 역지사지?  개발을 시작하기 전에 글에서 코드 최적화를 진행하는 가장 쉬운 방법으로 컴퓨터가 하는 일을 사람이 한다고 생각하면 된다고 설명했는데 이에 대한 간단한 예시를 보여드리고자 합니다.갑자기 분위기 K-메타버스설명은 역시 눈에 보이는 데이터가 있는 편이 이해에 편하겠죠? 이번엔 간단한 모델 필터를 이용해 설명드리려고 합니다. Blender 사용법에 대해서는 다루지 않고, 설명을 위한 부분만 추가 설명이 있을 예정입니다.우리가 작업하려는 것시작할 때 기본으로 생성되어있는 이 박스는, 8개의 정점(3D에서는 Vertices 라고 함)으로 이루어져있습니다.우리는 이 도형에 필터를 적용할 예정입니다.Subdivision 필터는 면을 분할하여 원래 모델이 보다 완만한 표면 각도가 되도록 구성합니다. 그 과정 중 원래 모델에 정점을 더 많이 추가하게 됩니다. 본래 기능은 이보다 복잡하지만 이정도로 설명할께요.그리고나서, 필터 처리된 개체를 복제해볼께요. 당연하지만, 이렇게 되면 총 점 갯수는 2배가 됩니다.작업 순서 정하기우리가 하려는 것은 기본 도형에 면 분할을 넣고 개체 복제하는 행동 입니다. 이 결과물을 완성하는 것은 매우 쉬운데, 우리가 선택해야하는 부분이 있습니다.      정육면체에 면 분할 효과를 적용한 후, 개체를 복제하기또는    정육면체를 먼저 복제한 후, 두 개체에 분할 효과를 적용하기  이 경우, 작업 순서가 바뀌더라도 결과물은 똑같이 나옵니다.  결과물이 똑같다면 그냥 아무렇게나 해도 상관없지 않나요?그렇게 생각할 수도 있지만 위 두 과정은 결과물이 같음에도 불구하고, 컴퓨터가 받는 부하량이 다릅니다.사람이 직접 한다고 대입해보기컴퓨터가 연산을 한다는 것은 사람이 수학 문제를 푸는 것과 같습니다. 컴퓨터가 자료 복제 행동을 하는 것은 사람이 손수 책을 따라쓰는 것과 같죠. 이렇게 생각하면 두가지 작업 순서에는 각각 장단점이 생기게 됩니다.면 분할 후 복사하기의 경우:  장점: 면 분할 계산을 1번만 해도 된다.단점: 복사할 내용이 많아진다. (면 분할 후 점 갯수가 늘어나므로)복사한 후 면 분할하기의 경우:  장점: 복사할 내용이 적다.단점: 면 분할 계산을 2번 해야한다. (컴퓨터 특성상 같은 연산이라도 처음부터 다시 계산하겠죠?)그리고 각 행동에 특징이 있습니다.  면 분할 계산: 세상에 존재하지 않는 결과값을 계산을 통해 얻어내는 것이므로, 머리가 뜨거워집니다(부하 많음).복제: 이미 준비된 내용을 따라 적는 것으로, 팔이 좀 아프겠지만 머리가 뜨거워질 정도는 아닙니다(부하 적음).컴퓨터의 자원 분배 상태에 따라 다르겠지만, 대체로 연산을 먼저 한 후 복사하는 것이 같은 결과물을 낼 때 효율적일 것이라는 것을 알 수 있습니다.이런 식으로, 결과물이 같더라도 더 효율적인 과정을 만들어내는 것이 사람들이 이야기하는 최적화입니다.실제 코딩에서는…멀티쓰레드 코딩이 등장하기 전까지, 모든 코드에는 순서가 있다고 했었죠?if (isObjectAvailable &amp;&amp; isButtonPressed) {     // ...}개체의 사용 가능 여부와 버튼이 눌렸는지 여부를 동시에 비교해야할 때 어떤 검토가 우선적으로 이루어지는게 검토량을 줄일 수 있을까요?function CalculatePosition() {    CheckIfUserInput();    CalculateVelocity();    CalculateAcceleometer();    // ...}사용자와 상호작용하는 개체 위치를 계산할 때 무엇이 먼저 계산되는 편이 연산을 조금 할까요?이제 우리가 컴퓨터를 심도있게 알지 못하더라도, 코드를 따라가면서 검토할 수 있습니다. 사람이 한다면 이런 순서가 쉬울까?라는 간단한 대입을 통해서 말이죠 😄"
  },
  
  {
    "title": "p5js로 시작하기 [4]",
    "url": "/posts/start-with-p5js-7/",
    "categories": "정보글, 개발",
    "tags": "scripting",
    "date": "2023-12-24 16:22:00 +0900",
    





    
    "snippet": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.이미 준비된 구조우리는 공 튀기기를 만들면서 공 하나에 필요한 거의 대부분의 구조를 만들었습니다. 그 구조를 개량하고 class로 만들어서 관리하면 될 것 같네요 👍일단 필요한 정보들을 추려서 class를 만들어봅시다.function setup() {  createCanvas(400, 4...",
    "content": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.이미 준비된 구조우리는 공 튀기기를 만들면서 공 하나에 필요한 거의 대부분의 구조를 만들었습니다. 그 구조를 개량하고 class로 만들어서 관리하면 될 것 같네요 👍일단 필요한 정보들을 추려서 class를 만들어봅시다.function setup() {  createCanvas(400, 400);  ball = new Ball(30, 30)}var ball;function draw() {  background(220);  ball.update();}class Ball {  // 공마다 시작 위치가 달라야하니 위치는 직접 받습니다.  constructor(_pos_x, _pos_y) {    // javascript 에서는 class 내에 별도 선언 없이 this.*를 사용하여 실시간 선언    this.pos_x = _pos_x;    // 이 클래스의 pos_y에, 밖에서 받아온 _pos_y를 사용하겠다    this.pos_y = _pos_y;    this.speed_x = 5;    this.speed_y = 2;    this.acc_y = 1;    this.direction_x = 1;    this.direction_y = 1;  }    update() {    this.pos_x += this.speed_x * this.direction_x;    this.pos_y += this.speed_y * this.direction_y;        if (this.pos_x + 10 &gt; width || this.pos_x &lt; 10) {      this.direction_x *= -1;    }    if (this.pos_y + 10 &gt; height) {      this.acc_y *= -1.2;    }    if (this.pos_y + 10 &gt; height || this.pos_y &lt; 10) {      this.direction_y *= -1;    }    if (this.pos_y + 10 &gt; height) {      this.pos_y = height - 10;    }    this.speed_y += this.acc_y;    circle(this.pos_x, this.pos_y, 20);  }}클래스 안에 update() 함수는 클래스에는 매 프레임마다 실행되는 함수가 없어서 draw() 함수에서 매 프레임마다 실행시키려고 만든겁니다.더 많은 공이제 우리는 공에 대한 구조를 가지고 있으니, 더 우아하게 공을 만들 수 있습니다.function setup() {  createCanvas(400, 400);  ball = new Ball(30, 30)+  ball2 = new Ball(45, 60);}var ball;+var ball2;function draw() {  background(220);  ball.update();+  ball2.update();}단 세줄의 코드를 추가해서 말이죠!더 더 더 많은 공근데 이런 식이면, 공을 만들 때 마다 코드가 3줄씩 늘어나는 작은 비극이 있습니다. 지금은 공이 2개니 별 문제 없지만, 공이 100개, 1000개 필요할 경우 관리가 복잡해질 것 같네요.이 부분에서 우리는 코딩의 꽃인 반복문을 사용해볼 수 있습니다.반복하는게 아니고 공을 좀 더 만드는 것 뿐인데조금 다르게 생각할 필요가 있습니다. 그냥 여러개를 만드는게 아니라 공 만들기를 여러번 반복한다라구요.개체 생성 반복하기대표적인 반복문으로 for()문이 있습니다.기본 모양새는 이렇게 되어있습니다.// 기본 구성for (let i = 0; i &lt; 100; i++) {  // 반복 행동 코드 블럭  console.log(i, '번째 반복 시행.');}이렇게 구성되어 있구요,for (&lt;변수 선언&gt;; &lt;조건문&gt;; &lt;변형&gt;) {  &lt;코드 블럭&gt;}이 순서로 동작합니다.for ( (0) ; (1) ; (3) ) {  (2)}구성 따라가기위 예시에 있는 for()문을 따라가면      변수 i를 선언하고, i = 0 으로 설정합니다.    i(0) &lt; 100 인가요? - true    반복 행동 코드 블럭을 실행하여 0번 반복 시행. 을 콘솔에 출력합니다.    i++ 처리 해줍니다. (이제 i = 1)    i(1) &lt; 100 인가요? - true    반복 행동 코드 블럭을 실행하여 1번 반복 시행. 을 콘솔에 출력합니다.    i++ 처리 해줍니다. (이제 i = 2)…    i(99) &lt; 100 인가요? - true    반복 행동 코드 블럭을 실행하여 99번 반복 시행. 을 콘솔에 출력합니다.    i++ 처리 해줍니다. (이제 i = 100)    i(100) &lt; 100 인가요? - false    반복문 이후 코드를 실행합니다  이런식으로, 변수 선언은 시작할 때 한번만 진행한 후 조건이 거짓이 될 때까지 코드 블럭을 반복시행합니다.이 때, 코드 블럭에서 반복하는 행동을 이번 프레임 안에 전부 실행합니다. 이러한 특성으로 인해, 1프레임(보통 1/60초) 안에 반복문이 해결되지 않으면 프로그램이 멈추거나 화면이 두둑두둑 끊기는 현상을 마주할 수 있습니다.코드 블럭과 지역 변수함수는 무엇인가 글에서 코드 블럭 얘기를 하며 코드의 지역 구분이라는 표현을 썼었습니다. 지금이 설명할 적기인 것 같군요.우리가 중괄호 {}를 사용하여 코드를 작성하면, 중괄호 안쪽에는 일종의 지역이 형성됩니다.var TargetNumber = 20;let TestThis = 'Test';function TestThis() { // &lt;-- 이 지역은 함수  if (TargetNumber &lt; 20) { // &lt;-- 이 지역은 조건문 발동 부분    let ThisNumber = 10;    var Variable = 'Text';    console.log('숫자가 작습니다');  }}지역 내에도 변수를 만들 수 있는데 이런 경우 지역 변수라고 부르며 그 지역을 벗어나는 경우 변수가 삭제됩니다. 자바스크립트의 경우 변수 선언하는 방식이 var와 let 두가지가 있는데  var: 지역과 무관하게 사용할 수 있음 (전역 변수)let: 해당 지역을 벗어나면 사용할 수 없음 (지역 변수)      둘 다 변수 종류에 자유로움  이렇게 동작합니다.이제 다시 반복문 코드를 보면// for()문의 선언부에서 생성된 i 는for (let i = 0; i &lt; 100; i++) {  // 이 코드 블럭을 반복할 때까지만 사용 가능하고  console.log(i, '번째 반복 시행.');}// 코드 블럭을 벗어나면 사용할 수 없습니다. (선언되지 않은 변수라고 오류 발생)반복문으로 변수 관리하기이제 반복문을 쓸 수 있게 되었으니, 여러 변수를 한번에 다루는 방법만 알아내면 되는데요. 아쉽게도 지금과 같은 방법으로는 변수를 한번에 관리할 수 없습니다.var ball_0;var ball_1;var ball_2;...  이런 식으로 변수를 생성하고 for()문을 사용하면 되지 않나요?네! 개념적으로 완벽하게 접근하셨는데 ball_n의 방식으로 변수를 불러오는 것은 컴퓨터 구조상 어렵습니다. 대신 그 작업에 적합한 변수 종류가 있습니다.배열(Array)우리는 편하게 쓰고 있지만 사실 변수에는 문자, 숫자 등의 다양한 종류가 있다고 했죠?그러한 종류 중 하나로 배열이 있습니다. 배열은 변수가 적힌 리스트 종류로, 그림에 있는 체크리스트 판 자체가 이에 해당합니다.var Array = [];코드에서는 이런 식으로 생성할 수 있습니다.배열의 경우, 자료를 구분/관리하는 첫 칸이 숫자로 되어있어 줄 세워서 일괄 처리하기에 용이합니다. 정보는 예시 이미지처럼 포인터(램 주소)가 될 수도 있지만, 바로 담아낼만큼 작은 정보라면 직접 작성되기도 합니다.또한 배열 변수는 변수가 적힌 리스트 그 자체가 아니고, 변수가 적힌 리스트가 배정받은 포인터를 저장합니다. 이것에 대해서는 다른 글에서 다룰께요.리스트에 정보 추가하기이러한 리스트에 정보를 작성하려면 변수명[첫 칸] = 값이라서 작성하시면 됩니다. 컴퓨터의 고질적 구조 덕분에 숫자를 0부터 세는 녀석이긴 하지만, 상식은 없어도 일 잘하는 녀석이니까, 그 정도는 우리가 맞춰줍시다.우리가 만든 공을 저 리스트에 담아 관리하려면 대충 이런 모양새가 되어야겠네요.function setup() {  createCanvas(400, 400);-  ball = new Ball(30, 30);+  ball[0] = new Ball(30, 30);}-var ball;+var ball = [];function draw() {  background(220);-  ball.update();+  ball[0].update();}...아, 리스트 0번에 입력한 공이 평소처럼 잘 튀깁니다.드디어, 지금이야 말로 더 더 많은 공 !이제 앞서 사용해본 for()문과 합쳐서 만들어봅시다.일단 배열에는 push()라고 하는, 배열 맨 뒤에 값을 추가하기 함수가 있습니다. 리스트가 막 생성된 빈 리스트라면 0번 리스트를 추가하고, 0번에 값이 있으면 1번에 값을 추가하는 식이에요.이 기능을 이용해서 공을 만들려면function setup() {  createCanvas(400, 400);-  ball[0] = new Ball(30, 30);+  for(let i = 0; i &lt; 100; i++) {+    let newBall = new Ball(30, 30);+    ball.push(newBall);+  }}이런 식으로 반복 생성을 할 수 있고, 이 모든 공들은 업데이트가 되어야하니function draw() {  background(220);-  ball[0].update();+  for (let i = 0; i &lt; ball.length; i++) {+    ball[i].update();+  }}이런 식으로 전부 업데이트 해줘야겠습니다. length 변수는 숫자 리스트 타입에 내장된 변수로, 현재 리스트에 몇줄의 정보가 적혀있는지를 알려줍니다. 우리의 경우, 내용을 100개를 만들었으니 100을 돌려줍니다.공이 하나뿐이 없어요100개의 공이 전부 같은 위치에서 시작하여, 같은 방식으로 튀기기 때문에 완벽하게 겹쳐보이는 것입니다. random() 함수를 사용하여 임의의 숫자를 마구잡이 만들어서 공을 만들 때 대입해봅시다.function setup() {  createCanvas(400, 400);  for(let i = 0; i &lt; 100; i++) {-    let newBall = new Ball(30, 30);+    let random_x = random(width);+    let random_y = random(height / 2);+    let newBall = new Ball(random_x, random_y);    ball.push(newBall);  }}완성!이제 공끼리 서로 튀기게 해주세요아뇨, 우리는 거기까지 진행하지는 않을 겁니다.부담없이 코딩을 시작할 수 있는 구성의 일부로서 진행한 것일 뿐입니다. 지금까지 작성된 코드로 공끼리 튀기기를 구현하려면 생각보다 많은게 다시 작성되어야 합니다. (이 짧은 코드에서 재작성이 많이 된다니.. ! )물론 class 구조를 좀 더 연습하고 싶다면 개인적으로 진행해보는 것을 추천합니다. 코딩을 잘한다는 것은 코드를 얼마나 잘 쓰는지가 아니라, 코드를 얼마나 잘 구성하는지이기 때문에, 별 것 아닌 것 같다고 생각되는 것도 직접 코딩하며 경험을 쌓는 것은 큰 도움이 됩니다.농담같았던 게임엔진 사용이 곳에서는 고도엔진을 다룰 예정입니다. 이 글을 작성하는 주인장은 고도엔진 4버전의 훌륭한 도약에 매우 예의주시 중입니다.이에 대해 관심이 있다면 고도엔진 뉴스 페이지에서 정보를 둘러보세요 😄이럴거면 공을 굳이 왜 튀긴거죠?우리가 연습삼아 진행했던 공 튀기기를 게임엔진에서 만들면 엄청 빠른 속도로 구성할 수 있습니다. 그냥 벽 개체, 공 개체, 약간의 개체 설정을 해두면 끝납니다. 게임 엔진에서는 개체의 질량, 중력, 마찰력 등 수많은 물리 연산 덩어리를 제공해주니까요. 그리고 그러한 연산 덩어리는, 우리가 직접 코딩한 것처럼, 누군가 정성스럽게 코딩한 것입니다.우리는 그것을 이해하기 위해 연습한 겁니다. 그 모든 것들이 누군가 만든 코드지, 컴퓨터가 자동으로 제공해준게 아니란 것을 몸소 체험한 겁니다.그러니까 기억하세요.원하는 동작하는 방식을 본인이 명확히 이해하고 있다면, 무엇이든 만들 수 있습니다.직접 코딩하는 경험이 많아질수록, 어디까지든 점점 더 명확해질 겁니다."
  },
  
  {
    "title": "클래스란 무엇인가",
    "url": "/posts/what-is-class/",
    "categories": "정보글, 개발",
    "tags": "쉬운설명, scripting",
    "date": "2023-12-22 05:09:00 +0900",
    





    
    "snippet": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.코드로 컴퓨터에게 일 시키기여러분은 햄버거집을 운영하는 사장입니다.지금껏 여러분이 코딩이라고, 컴퓨터에게 어떤 일을 시키던 것들은 버거집에서 알바생이 지켜야할 규칙들을 상세하게 적어내려가는 일이었고, 그 일을 처리하는 알바생은 컴퓨터인데 이녀석은 매우 멍청하지만 매우 정직합니다. 다르게 ...",
    "content": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.코드로 컴퓨터에게 일 시키기여러분은 햄버거집을 운영하는 사장입니다.지금껏 여러분이 코딩이라고, 컴퓨터에게 어떤 일을 시키던 것들은 버거집에서 알바생이 지켜야할 규칙들을 상세하게 적어내려가는 일이었고, 그 일을 처리하는 알바생은 컴퓨터인데 이녀석은 매우 멍청하지만 매우 정직합니다. 다르게 말하자면 상식은 전혀 통하지 않지만 하라는 일은 정확하게 해냅니다.이것이 오늘 코딩을 비유하는 방식입니다.효율적인 햄버거 레시피 관리클래스(class)는 ‘어떻게 하면 모든 햄버거 레시피를 쉽게 관리할 수 있을까?’라는 생각에서 출발한 개념으로  레시피를 보관할 때는 공간을 적게 차지하고  공통된 부분이 있는 것들을 관리할 때 용이하며  그러면서도 각 메뉴에 차별점을 두기 쉬운특징을 가지고 있습니다.알바생은 이 부분을 전혀 신경쓰지 않습니다. 이 알바생은 레시피가 100장이든 1000장이든 하라는 일은 정확하게 할 줄 아니까요. 아쉽게도 상식이 없어서 우리가 레시피를 잘못 관리하면, 예를 들어 버거에 된장을 바르라고 레시피를 남겨놓으면, 주저도 의심도 없이 그대로 일을 저질러버릴 겁니다. 그건 전적으로 우리 책임이 됩니다.우리 입장은 좀 다릅니다. 레시피가 100장, 1000장 늘어나면 뭔가 수정하고 싶을 때 100장, 1000장 다 읽어 검토하고, 변경해야하는 엄청난 수고를 해야합니다. 만약, 자연재해로 상추 가격이 높아져서 모든 버거에 들어가는 상추조각을 조금 줄여야한다고 생각해봅시다….정말로 1000장을 다 보면서 상추 수를 변경할 생각이신가요? 재해가 끝나면 다시 상추조각수를 원상복구 시켜야할텐데요 😢우리는 좀 더 효율적으로 레시피를 관리할 필요가 있습니다.공통 구성 찾기햄버거는 위, 아래가 빵입니다.적어도 우리 매장에서 팔고 있는 버거들은 모두 그런 모습입니다.그러니까, 우리 매장 레시피는 공통적으로 바닥 빵을 두고 시작합니다.class Burger {    constructor() {        // 버거를 제작할 때 일단 바닥 빵을 둡니다.    }    end_of_burger() {        // 버거를 마무리할 때 맨 위에 빵으로 덮습니다.    }}여기서 constructor()는 클래스가 생성될 때 시작하는 함수로 우리가 앞서 사용했던 setup()과 동일한 방식으로 동작합니다(생성될 때 단 한번 실행). constructor()는 클래스의 기본 구성요소로, 반드시 존재하고, 시작할 때 자동으로 동작합니다.아래 있는 end_of_burger()는 클래스 안에 있는 함수입니다. 호출해야 동작하는, 우리가 사용하던 그 함수에요.클래스는 함수도 변수도 구성/관리할 수 있습니다. 클래스라는건 뭔가 우리가 작성중인 스크립트의 축소판 같네요.우리는 다음 코드를 입력하여 우리의 새 버거를 만들어낼 수 있습니다.var NewBurger = new Burger(); // 새로운 버거 만들기아직 빵 밖에 없지만 말이죠 !빵은 같아도 내용물은 달라야해모든 메뉴에는 빵이 들어가지만 모든 메뉴에 치즈가 들어가진 않습니다.우리는 보통 메뉴 이름을 통해서 내용물을 구분하니까 그렇게 동작하도록 해야겠어요.class Burger {    constructor(name: String) {        // 버거를 제작할 때 일단 바닥 빵을 둡니다.        switch(name) {            case 'cheese':                // 치즈버거는 치즈를 올릴 겁니다.                break;        }        this.end_of_burger();    }    end_of_burger() {        // 버거를 마무리할 때 맨 위에 빵으로 덮습니다.    }}...var Burger = new Burger('cheese');constructor()도 함수와 동일하게 동작하기 때문에 인자 구성을 할 수 있습니다.그리고는 this라는걸 쓰게 되는데, 여기서 this는 Burger클래스를 말합니다. 영어 해석 그대로 이것(이 클래스)인 셈이죠..은 ~안에 라는 뜻입니다.this.end_of_burger()는 그러니까, 이 클래스에 안에 있는 end_of_burger() 함수를 쓰겠다는 뜻이 됩니다.더 다양한, 더 짧은 구성을 위해그런데 저런식으로 Burger 클래스를 구성하면 switch구문이 엄청 길어지겠죠?그러면 우리가 100장, 1000장의 레시피를 쓰는 것과 다를게 없어지잖아요..그래서 클래스에는 확장이라는 개념이 있습니다.class Burger {    constructor(name: String) {        // 버거를 제작할 때 일단 바닥 빵을 둡니다.    }    end_of_burger() {        // 버거를 마무리할 때 맨 위에 빵으로 덮습니다.    }}class CheeseBurger extends Burger {    constructor() {        super(); // 여기서 바닥 빵을 둡니다.        // 치즈버거에는 치즈가 들어갑니다.        this.end_of_burger(); // 빵 덮기    }}...var NewBurger = new CheeseBurger();새로운 클래스인 CheeseBurger는 Burger클래스를 상속받아 만들었습니다.(extends는 확장이란 뜻이니 직역하자면 Burger의 개념을 확장하여 정도가 됩니다)갑자기 생긴 super()는 상속받았던 클래스의 해당 함수, Burger 클래스의 constructor()를 실행시키겠다는 뜻입니다. 클래스에 내장되어 있는 기능입니다.CheeseBurger 클래스 안에 end_of_burger() 함수가 없는데도 this로 호출할 수 있는건 상속받았던 Burger 클래스에 있는 것을 그대로 사용할 수 있기 때문입니다.Burger로서 기본적으로 해야할 일들(시작하자마자 빵 두기, 마지막에 빵 덮기)이 이미 준비된 상태로 치즈버거일 때에만 해야할 일(치즈 넣기)만 신경써주면 치즈버거는 온전하게 만들어집니다.더 더 다양하게, 더 더 복잡하게메뉴 관리에 능숙해져, 몇장 안되는 레시피로 더 많은 메뉴를 관리하다보면 구조상 비슷하게 동작하긴하나 기본 개념을 타파하는 방식의 레시피를 준비하고 싶어질지 모릅니다.예를 들면 민트초코파인애플버거를 만들고 싶을지도 모르겠네요.위 아래가 빵이 아닌 파인애플조각인 녀석으로 말이죠. 안돼그 때부터는 다형성(Polymorphism)이라는 개념이 들어가는데 지금 다루지는 않을 예정입니다. 햄버거 예시로 지나가듯 쉽게 설명하자면 상속받은 클래스에서 일부 함수를 덮어씌워 재가공하는 방법(이 경우, end_of_burger() 에서 빵 대신 파인애플로 덮기) 같은걸 할 수 있습니다.햄버거로는 설명하기 어려운 개념들이 있으니 다음에 다른 예시로 준비해볼께요."
  },
  
  {
    "title": "p5js로 시작하기 [3]",
    "url": "/posts/start-with-p5js-3/",
    "categories": "정보글, 개발",
    "tags": "scripting",
    "date": "2023-12-18 03:27:00 +0900",
    





    
    "snippet": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.벽을 뚫고 나가는 공 문제우리가 마지막에 공을 움직이게 했지만, 이녀석은 벽을 뚫고 나가서 영원히 안돌아옵니다. 공이 조금 더 자연스럽게 보이게 하려면 공이 벽에 닿았을 때, 반대 방향으로 튕겨줘야 할 것 같아요.우리가 궁극적으로 “충돌체”의 개념을 만들면 아주 이상적이겠지만, 우린 아직...",
    "content": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.벽을 뚫고 나가는 공 문제우리가 마지막에 공을 움직이게 했지만, 이녀석은 벽을 뚫고 나가서 영원히 안돌아옵니다. 공이 조금 더 자연스럽게 보이게 하려면 공이 벽에 닿았을 때, 반대 방향으로 튕겨줘야 할 것 같아요.우리가 궁극적으로 “충돌체”의 개념을 만들면 아주 이상적이겠지만, 우린 아직 초심자니까, 좀 더 간단하게 생각해봅시다.  만약 공이 화면 끝에 닿게 되면, 이동 방향을 반대로 바꾼다.이렇게 말이죠....var pos_x = 30;+ var direction = 1;function draw() {  background(220);-  pos_x++;+  pos_x += 1 * direction; // pos_x = pos_x + 1 * direction 와 같음+  if (pos_x &gt; width || pos_x &lt; 0) {+    direction *= -1; // direction = direction * -1 와 같음+  }  circle(pos_x, 30, 20);}준비된 함수로 개체 생성한 것을 넘어선 첫 기능 추가입니다. 와 !동시에 처음으로 문제점도 맞이하게 되었습니다. 우선 코드 설명부터 차근차근 짚어가겠습니다.개발자는 적극적으로 게을러개발자는 극단적으로 효율을 찾습니다. 컴퓨터가 일을 “정확히” 처리하는 것에 촛점을 맞춰 좀 더 사람이 편하게 작업할 수 있도록 고민하죠. 이번에 처음 나온 표현인 pos_x += 1 * direction는 주석(코드에 적어두는 메모)에도 적어두었지만 pos_x = pos_x + 1 * direction과 같은 뜻입니다. 똑같은데 왜 다른 표현법이 존재하는가? 라고 묻는다면, 대표적으로 작성 편의와 가독성을 꼽을 수 있습니다.  될 수 있다면 같은 것을 반복해서 적고 싶지 않음  여기저기서 자주 사용하는 연산이라면 극단적으로 짧게 표현하여 자주 쓸 때 시간 절약라고 보시면 됩니다. 처음에 사용하였던 pos_x++이라는 표현까지 가져와서 설명을 드리자면 변수에 1씩 더하는 경우가 얼마나 자주 발생하는지, 그 순간마다 pos_x = pos_x + 1 (또는 pos_x += 1)이라고 적으려면 아마 골치가 아플겁니다.그리고 pos_x += 1에서 눈치를 채셨겠지만, + 대신 다른 사칙연산 부호(+=, -=, *=, /=)를 넣으면 해당 변수에 그러한 연산을 하여 다시 대입합니다.조건을 따져서 발동시켜처음으로 조건문인 if()가 등장했습니다. 영어 직역 그대로 만약라는 뜻이고, 괄호 안의 조건이 맞는 말이면(결과값이 true면) 따라오는 코드 블럭을 실행합니다. 그러니 if() 조건문은 괄호 안에 참인지 거짓인지만 받습니다.  잉? 무슨 소리에요.. 지금 pos_x &gt; width || pos_x &lt; 0 이런게 들어와있는데…하나씩 짚어가자면 이렇습니다.      || 는 그게 참(true)이 아니면 을 뜻합니다. &amp;&amp;는 동시에 뒷값도 참(true)이면를 뜻합니다.    width는 캔버스의 가로 길이로, p5js에서 제공하는 변수이고, 우리의 캔버스 크기는 현재 400입니다. (createCanvas()에서 설정됨)        캔버스를 재생시킵니다.    현재 프레임에서 pos_x의 값은 30 이네요    현재 pos_x(30)이 width(400) 보다 큰가? =&gt; 아뇨 작죠, 이 명제는 거짓입니다. (false)    그게 참이 아니면 (실제로 참이 아니었음)    현재 pos_x(30)이 0보다 작은가? =&gt; 아뇨 크죠, 이 명제는 거짓입니다. (false)    맞는 말이 단 하나도 없으니 뒤따라오는 코드 블럭을 실행하지 않음.  저런 식으로 두 값을 비교하여 맞는지 틀린지를 알려주는 것을 비교연산자라고 합니다. 지금은 위치가 어떤지, 두 숫자를 비교하지만 'A' != 'B'처럼 문자나 자료들을 비교할 수도 있습니다. 이 내용은 다른 포스트에서 다루도록 할께요.어째뜬 비교연산자는 두 대상을 비교하여 비교 결과가 참(true)인지 거짓(false)인지를 돌려줍니다.그리고 참, 거짓들끼리도, 위처럼 추가적인 비교가 있을 때 간단한 연산이 일어납니다.추가적인 참-거짓 연산은 다음과 같이 일어납니다.&amp;&amp;(동시에 뒷값도 참이면)연산은 앞값과 뒷값이 동시에 맞는 말일 때 참값을 돌려줍니다.      true &amp;&amp; true: true    true &amp;&amp; false: false    false &amp;&amp; true: false (이 경우 뒷값 연산을 하지 않음)    false &amp;&amp; false: false (이 경우 뒷값 연산을 하지 않음)  컴퓨터가 순차적으로 동작한다던 글을 기억하시나요?&amp;&amp;(동시에 뒷값도 참이면)연산에서 앞값이 진작에 거짓으로 판명났다면, 뒷값이 참이든 거짓이든 결과가 거짓이기 때문에 뒷값 연산은 아예 진행하지 않습니다.||(그게 참이 아니면)연산은 둘 중 하나만 참이어도 참입니다. 애초에 앞값이 참이면 그게 참이 아니지 않잖아요 ㅎㅎ      true || true: true (이 경우 뒷값 연산을 하지 않음)    true || false: true (이 경우 뒷값 연산을 하지 않음)    false || true: true    false || false: false  ||(그게 아니면)연산에서도 마찬가지로, 앞값이 진작에 참으로 판명나면 뒤까지 굳이 넘어가지 않습니다. 어차피 참이기 때문이죠.결국 저 조건문은 화면이 오른쪽 끝(위치가 400보다 커질 때)와 왼쪽 끝(위치가 0보다 작아질 때)에 있을 때 동작하게 됩니다.첫 문제점코드 자체는 별 문제가 없지만 우리가 그린 원이 반쯤 화면 밖으로 튀어나가는 것을 볼 수 있을 텐데요. 이건 우리가 원이 튕기는 위치를 원 중심 기준으로 코딩했기 때문입니다. 원의 반지름만큼 일찍 비교하면 정말로 원이 화면에 튕기는 것처럼 보이게 됩니다....  pos_x += 1 * direction;-  if (pos_x &gt; width || pos_x &lt; 0) {+  if(pos_x + 10 &gt; width || pos_x &lt; 10) {    direction *= -1;  }}오늘까지의 스크립트function setup() {  createCanvas(400, 400);}var pos_x = 30;var direction = 1;function draw() {  background(220);  pos_x += 1 * direction;  if (pos_x + 10 &gt; width || pos_x &lt; 10) {    direction *= -1;  }  circle(pos_x, 30, 20);}여기저기 막 적용해보자할 줄 아는게 생겼으니 공이 위/아래로도 움직일 수 있게 하고 속도도 조금 변화를 주고 해봅시다.function setup() {  createCanvas(400, 400);}var pos_x = 30;var pos_y = 30;var speed_x = 1;var speed_y = 2;var direction_x = 1;var direction_y = 1;function draw() {  background(220);  pos_x += speed_x * direction_x;  pos_y += speed_y * direction_y;  if (pos_x + 10 &gt; width || pos_x &lt; 10) {    direction_x *= -1;  }  if (pos_y + 10 &gt; height || pos_y &lt; 10) {    direction_y *= -1;  }  circle(pos_x, pos_y, 20);}각 x, y축의 속도도 방향도 전부 변수로 바꾸면 나중에 공에 변화를 주기 좋겠죠?아주 아름답게 동작하고 있습니다.살면서 쓸모없는줄 알았는데근데 지금 공은 진공 상태에서 떠다니는 것처럼 보입니다. 현실에서 공이 움직일 때에는 좀 더 포물선을 그리며 움직이잖아요?  헉… 곡선의 움직임을 어떻게 따라하죠?우리가 변수에 직접 계산하지는 않을거에요, 우리가 해야할 일은 컴퓨터에게 올바른 구조를 제시하는 것이니까요.속도에 대한 이야기를 해야겠네요. 잠시 학창시절 과학 시간으로 돌아가서…지금 draw() 함수는 매 순간(정확히는 1/60초)마다 한번씩 실행되고 있습니다. 우리가 위치에 매 순간마다 speed 값만큼 추가를 하는 것은 우리가 현실에서 말하는 속도와 일맥상통 합니다. 속도라는게, 거리/시간이잖아요? 우리 코드는 지금 speed(1만큼)/매 순간(1/60초)마다 이동하는거라구요.우리는 일상 생활중에 중력의 영향을 받죠? 중력은 조금 길게 적으면 중력가속도라고 하죠. 우리 코드에 가속도에 해당하는 개념을 넣으면 코드는 알아서 포물선을 그리게 될 겁니다.으아악! 그래서 어떻게 하면 되는데요가속도라는 것은 매 순간마다의 속도 변화량입니다. 곧 중력의 영향을 받게 될 speed_y는 매 순간마다 1의 속도로 움직이는, 속도 변화량이 0인 상태죠? 가속도가 전혀 없는 등속 운동중이어서 진공 상태마냥 무미 건조하게 움직이고 있는거에요. 한번 가속도를 넣어보도록 할까요?... // 변수 지정에서..var pos_y = 30;- var speed_x = 1;+ var speed_x = 5; // 포물선이 더 잘 보이도록 x축 속도를 늘렸습니다.var speed_y = 2;+ var acc_y = 1;var direction_x = 1;... // draw() 함수에서..  if (pos_x + 10 &gt; width || pos_x &lt; 10) {    direction_x *= -1;  }+  if (pos_y + 10 &gt; height) {+    acc_y *= -1; // 바닥에 닿으면 반대로 튕기기+  }  if (pos_y + 10 &gt; height || pos_y &lt; 10) {    direction_y *= -1;  }+  speed_y += acc_y; // 이제 매 순간 속도가 변화합니다}뭔가 잘 동작하는 것 같으면서도 의도한 적은 없는데 점점 튕기는 정도가 낮아지고 있고, 궁극적으로 마지막에 갑자기 땅을 파고 드는 문제가 생겼네요. 우리가 뭔가 놓치고 있는게 분명합니다.연산 최적화에 대해서..같은걸 굳이 또 계산하는 것 같은데..놓친 것들을 되짚어보기 전에, 작은 최적화 처리에 대해서 이야기하고자 합니다. 일단 코드를 봅시다....  if (pos_y + 10 &gt; height) { // &lt;-- 여기    acc_y *= -1;  }  if (pos_y + 10 &gt; height || pos_y &lt; 10) { // &lt;-- 여기    direction_y *= -1;  }...pos_y + 10 &gt; height 이 똑같게 2번 적힌 것을 확인하실 수 있는데 컴퓨터는 저 연산을 두 번 다 합니다.무슨 말이냐면, 예를 들어 첫 줄에서 pos_y + 10 &gt; height를 연산해서 그 결과가 false라는 것을 알게 되었더라도, 두번째에 가서 pos_y + 10 &gt; height를 다시 연산한다는 겁니다.  엥? 왜 굳이 그러죠?컴퓨터는 하라는대로 하는 애니까요. 해당 연산은 너무나도 간단하여 매 순간 2번 연산한다고 연산장치(CPU)가 힘들어하지는 않겠지만, 우리는 초심자니 처음 맞이한 이 상황에서 연습을 좀 합시다....  pos_y += speed_y * direction_y;+  let pos_y_overHeight = pos_y + 10 &gt; height;  if (pos_x + 10 &gt; width || pos_x &lt; 10) {    direction_x *= -1;  }-  if (pos_y + 10 &gt; height) {+  if (pos_y_overHeight &gt; height) {    acc_y *= -1;  }-  if (pos_y + 10 &gt; height || pos_y &lt; 10) {+  if (pos_y_overHeight &gt; height || pos_y &lt; 10) {    direction_y *= -1;...이런 식으로, pos_y_overHeight 변수를 만들어서 기억해두었다가 다시 사용하면 연산량을 줄일 수 있습니다. let에 대해서는 다음에 따로 설명을 드릴 것인데, 일단 var와 비슷한 녀석으로만 알아주세요.하지만 기억할게 늘어났잖아요네, 맞아요. 최적화는 생각보다 더 많은 고민을 요구합니다. 위와 같은 경우, CPU가 연산을 더 할지, RAM이 용량을 더 쓸지 중에서 고르는 것이고, 이러한 저울질 결과는 매 상황마다 다릅니다. 해당 코드가 동작하는 순간 RAM 사용량이 많을 것 같다면 CPU가 부하를 더 받는 방향으로, 반대로 CPU가 부하를 많이 받을 것 같다면 RAM에 보관하는 방향으로 진행하는 것이죠.오로지 개발자의 판단을 따라갑니다. 컴퓨터는 그 판단을 완벽하게 따라가려고 노력할거에요.물론 우리의 공 튀기기 프로젝트는 너무 가벼워서 개막장으로 짜도 동작할 예정이지만요 😆배우는 과정중에 나오는 짜투리 이야기라고 생각해주세요공에는 대체 무슨 일이 일어나는 중이죠?코드가 동작하는 매 순간(1/60초)을 뜻하는 말로 프레임레이트(framerate)가 있습니다. p5js에도 매 순간의 기준을 지정할 수 있는 frameRate()라는 함수가 있습니다. frameRate() 문서를 보아하니, frameRate()함수를 써서 얼마나 자주 연산할지 변경할 수 있네요. 검토를 위해 천천히 돌려보도록 하죠.function setup() {  createCanvas(400, 400);+  frameRate(5);}한번 설정하면 계속해서 1초에 5번 재생하게 되니 setup() 함수에 넣도록 하겠습니다.너무 빨리 동작해서 놓치던 문제가 눈에 보이기 시작하는군요. 가속도가 붙은 공이 땅을 뚫는 문제가 있었어요.바닥에 닿으면 반대쪽으로 튕기라고 했는데요?정확히 말하자면 아닙니다. 우리가 하라고 한 것은 공의 높이가 화면크기보다 커지면 속도와 가속도에 -1을 곱하여 반대로 움직이라고 한겁니다. 컴퓨터는 바닥에 닿는다 라든가, 반대로 튕긴다 같은 개념을 전혀 모르고 있습니다.저 문제가 발생하는 것은 가속도개념이 들어와서 그런겁니다.오프 더 레코드로 도움이 되는 정보를 보여드리자면, 가속도에 영향을 받아 속도가 커지니, 화면에 거의 닿았다라는 판단을 벽을 뚫고나서야 알게 되는 것이죠.예전에는 위치에 1씩 더했는데 지금은 위치에 거의 27을 더하니까요.이건 또 어떻게 고쳐요?모든 연산이 끝나갈 즈음에, 높이를 인위적으로 재조정하면 됩니다.앞서 알려드린 pos_y_overHeight 변수를 사용하면 더욱 좋습니다....  if (pos_y + 10 &gt; height || pos_y &lt; 10) {    direction_y *= -1;  }+  if (pos_y + 10 &gt; height) {+    pos_y = height - 10;+  }  speed_y += acc_y;}그러면 시작 위치까지 뛰어오르며 영원히 튀기는 공을 보실 수 있습니다좀 더 현실처럼현실에서는 바닥에 공이 닿으면 운동 에너지가 소리 에너지 등 다른 에너지로 전환되어 원 위치까지 올라오지 못하죠. (중등 과학은 여기까지 😅)조금 더 그럴싸한 결과물을 위해 다음과 같이 코드를 수정할 수 있을 것 같습니다....  if (pos_x + 10 &gt; width || pos_x &lt; 10) {    direction_x *= -1;  }  if (pos_y + 10 &gt; height) {-    acc_y *= -1;+    acc_y *= -1.2;  }  if (pos_y + 10 &gt; height || pos_y &lt; 10) {    direction_y *= -1;  }...튕길 때 가속도를 더 받는 방법으로 점점 높이가 낮아지게 하는거죠.정리지금까지의 코드를 정리하자면 이렇게 됩니다.function setup() {  createCanvas(400, 400);}var pos_x = 30;var pos_y = 30;var speed_x = 5;var speed_y = 2;var acc_y = 1;var direction_x = 1;var direction_y = 1;function draw() {  background(220);  pos_x += speed_x * direction_x;  pos_y += speed_y * direction_y;  if (pos_x + 10 &gt; width || pos_x &lt; 10) {    direction_x *= -1;  }  if (pos_y + 10 &gt; height) {    acc_y *= -1.2;  }  if (pos_y + 10 &gt; height || pos_y &lt; 10) {    direction_y *= -1;  }  if (pos_y + 10 &gt; height) {    pos_y = height - 10;  }  speed_y += acc_y;  circle(pos_x, pos_y, 20);}여기서 상상력을 더 발휘하여 공을 여러개 만든 다음에 공끼리도 튕기는 구성 같은 것을 생각해낼 수 있을 겁니다. 하지만 지금까지 알게 된 내용으로는 구성하고 싶지 않을꺼에요… 엄청난 노가다가 될 것이거든요. 공의 갯수가 늘어갈 때마다 7개의 변수가 생기고, 각 변수들이 벽이나 다른 공에 닿을 때마다 속도를 바꾸고, 서로 튕겨야하니까요.  어라? 이거 함수처럼 뭔가 단순화시킬 방법이 있지 않을까요?네, 맞습니다. 우리가 다루려는 저 공을 객체화시킬 수 있는 훌륭한 방법이 있습니다.다음 포스트에서 다루려고 합니다."
  },
  
  {
    "title": "함수란 무엇인가",
    "url": "/posts/what-is-function/",
    "categories": "정보글, 개발",
    "tags": "쉬운설명, scripting",
    "date": "2023-12-17 17:06:00 +0900",
    





    
    "snippet": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.방금 무슨 일이 일어난거지?우리는 방금 마법같은 일을 경험했습니다. 한 줄의 코드로 원을 그렸기 때문이죠.function setup() {  createCanvas(400, 400);}var pos_x = 30;function draw() {  background(220);  circle...",
    "content": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.방금 무슨 일이 일어난거지?우리는 방금 마법같은 일을 경험했습니다. 한 줄의 코드로 원을 그렸기 때문이죠.function setup() {  createCanvas(400, 400);}var pos_x = 30;function draw() {  background(220);  circle(pos_x, 30, 20); // &lt;-- 이 자리  pos_x++;}저 circle()이 뭐길래 원을 그리는 걸까요?저렇게 뒤에 괄호가 붙은 것을 우리는 함수라고 합니다. 잘 보시면 setup()도 draw()도 뒤에 괄호가 붙어있죠? 그것들도 함수입니다.function이 애초에 함수라는 뜻입니다 ^^;변수 구성할 때 &lt;종류&gt; &lt;이름&gt;이었던 것을 겹쳐보신다면 더 체감이 되실겁니다. 함수는 종류가 함수로 선언되어있습니다. 구성상 괄호가 따라 붙는 것이구요.함수가 그래서 뭐에요?학생 때 배웠던 원의 방정식을 기억하시나요?x^2 + y^2 = r^2이 함수를 사용하면 좌표 중심에 원을 그릴 수 있었습니다.그리고 이것은 수학이니, 우리가 컴퓨터에서 숫자를 잘 다루면, 컴퓨터에서 원을 그릴 수도 있을 것 같습니다. 화면에 원을 그릴 땐 위치나 크기 뿐 아니라 선의 색상, 원의 색상 등 원을 표현하는 방식도 필요하니 좀 더 다양하고 복잡한 모양새가 되겠죠. 그러니 원을 그리고 싶다면…// --- 여기부터 ---// 원의 중심점 설정// 원의 크기에 따라 동그랗게 그리기// 원의 선 색상을 검정색으로 하기// 원의 안쪽 면 색상을 흰 색으로 하기// ... 기타 원에 관련된 설정들 잡기// --- 여기까지 작성하면 원 그리기 완성 ---실제 코드를 적어내려가면 복잡할 것 같아서 간략하게 썼는데도 저렇게 최소 4줄 이상을 작성해야 원을 그릴 수 있게 됩니다. 코드에서 원을 그려야하는 순간들마다 4줄씩 복사/붙여넣기하여 크기나 위치 같은 다른 값들만 수정하는 방식을 생각해보세요. 코드가 순식간에 정신없이 길어질 겁니다. 원을 10개만 그려도 코드는 40줄…!편하게 반복하기좀 더 관리하기 편한, 가독성이 좋은 코딩을 하기 위해 생겨난 것이 함수입니다.function circle() {    // 원의 중심점 설정    // 원의 크기에 따라 동그랗게 그리기    // 원의 선 색상을 검정색으로 하기    // 원의 안쪽 면 색상을 흰 색으로 하기    // ... 기타 원에 관련된 설정들 잡기}이런 식으로 양식에 맞추어 원 그리기 함수를 구성한 후에circle(); // circle() 함수에 구성된 행동을 그대로 실행하기이런 방식으로 호출하면 저 함수에 작성한 것들을 동일하게 동작시켜줍니다.와 !이제 원을 10개 그릴 때 코드를 40줄 쓰지 않고 10줄만 써도 되요!비슷하지만 다를 수 있게하지만 위와 같은 방식으로 함수를 구성하면 단점이 있습니다.모두 같은 좌표 중심에, 같은 크기, 같은 속성의 원을 그리게 됩니다. 함수에 적혀있는 내용은 고정적이고 프로그램을 재생할 때 우리가 임의로 수정할 수가 없으까요. 그래서 사람들은 생각했습니다. 함수 중 일부는 변수로 구성될 수 있지 않을까 하고 말이죠.function circle(position_x, position_y) {    // 원의 중심점 설정 (중심점은 받아온 position_x, position_y 값에 영향받음)    // ...}이런 식으로 괄호 안에 인자를 받아 함수에 사용되는 값을 직접 변경할 수 있게 구성하는 겁니다. 그러면 여전히 원을 그릴 때 함수 한 줄로 그릴 수 있지만 각 원마다 변화를 주기도 쉬워집니다.circle(0, 0); // 좌표 중심에 원 그리기circle(10, 10); // (10, 10) 자리에 원 그리기...우리가 사용한 circle() 함수는 원의 지름까지 받았었죠? 같은 방식으로 지름 인자를 추가한 것이라 생각하시면 됩니다.코드 블럭함수에서 괄호 뒤에 {} 이런 중괄호도 사용했는데, 이것은 코드 블럭입니다. 코드 묶음 정도로 생각하면 됩니다. 이 코드 블럭은 코드의 지역 구분을 의미하는데 이건 다음에 따로 설명하도록 할께요."
  },
  
  {
    "title": "p5js로 시작하기 [2]",
    "url": "/posts/start-with-p5js-2/",
    "categories": "정보글, 개발",
    "tags": "scripting",
    "date": "2023-12-16 01:10:00 +0900",
    





    
    "snippet": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.난 이제 뭐든 할 수 있어 !우리는 이제 변수가 뭔지 압니다. 그럼 변수에 어떤 값을 저장시킬지, 어떤 변화를 줄지 같은 것을 계획할 수 있죠. 우리는 아직 초심자니까, 연습 삼아 움직이는 동그라미 같은걸 그릴 수 있을지 몰라요.움직이는 원 그리기일단 이 페이지에서 문서를 읽어보니 원은 ...",
    "content": "  이 글에는 이해를 돕기 위한 거짓말이 조금 포함되어 있습니다.난 이제 뭐든 할 수 있어 !우리는 이제 변수가 뭔지 압니다. 그럼 변수에 어떤 값을 저장시킬지, 어떤 변화를 줄지 같은 것을 계획할 수 있죠. 우리는 아직 초심자니까, 연습 삼아 움직이는 동그라미 같은걸 그릴 수 있을지 몰라요.움직이는 원 그리기일단 이 페이지에서 문서를 읽어보니 원은 circle(원의 중심x, 원의 중심y, 지름의 크기)로 그릴 수 있는 것 같네요. 주저 없이 그려봅시다.function setup() {  createCanvas(400, 400); // 캔버스가 있어야 그림을 그릴 수 있으니 냅두고}function draw() {  background(220); // 배경도 일단 냅둡니다  circle(30, 30, 20); // 예제에 있던 코드를 따라 써보기}우리는 변수를 쓸 줄 아니까 약간 변형을 가해보죠.일단 x축 위치에 적당히 이름을 붙여 따로 기억하기로 하고,...+ var pos_x = 30; // position xfunction draw() {  background(220);-  circle(30, 30, 20);+  circle(pos_x, 30, 20);}...매 순간마다 위치 값에 1씩 추가해줍시다....function draw() {  background(220);+  pos_x++;  circle(pos_x, 30, 20);}...여기서 ++은 에 1을 더한다는걸 짧게 적은 것으로, 위의 경우 `pos_x = pos_x + 1;`과 동일한 의미가 됩니다.pos_x = pos_x + 1;를 길게 풀어 적으면 RAM에서 pos_x 위치에 뭘 저장할거냐면, RAM에서 pos_x 위치에 있는 값을 가져와서 1을 더한 것을 저장할거야 가 됩니다.그러고나면원이 움직이게 됩니다 !근데 저 원은 대체 어떻게 그리는걸까요?깊게 파고 들 생각은 없고, 아주 조금만 설명하고자 합니다."
  },
  
  {
    "title": "동적 프로그래밍 언어",
    "url": "/posts/dynamic-lang/",
    "categories": "정보글, 개발",
    "tags": "쉬운설명, scripting",
    "date": "2023-12-15 12:39:00 +0900",
    





    
    "snippet": "이러지 않으려고 했는데쉬운 언어 위주로 설명글을 남길 것이기 때문에 굳이 이 부분을 적어야할까..? 생각이 들었지만 역시 적어두는 편이 좋겠다고 생각이 들었습니다.두리뭉실한 언어의 역사라는 느낌으로 슥 읽어보시면 좋을 것 같습니다.물론 원활한 설명을 위한 거짓말이 포함됩니다.옛날 옛날에컴퓨터는 수많은 0, 1로 이루어져있습니다. 그것이 실제로는 전기 ...",
    "content": "이러지 않으려고 했는데쉬운 언어 위주로 설명글을 남길 것이기 때문에 굳이 이 부분을 적어야할까..? 생각이 들었지만 역시 적어두는 편이 좋겠다고 생각이 들었습니다.두리뭉실한 언어의 역사라는 느낌으로 슥 읽어보시면 좋을 것 같습니다.물론 원활한 설명을 위한 거짓말이 포함됩니다.옛날 옛날에컴퓨터는 수많은 0, 1로 이루어져있습니다. 그것이 실제로는 전기 신호라 할지라도 숫자 세는건 참 쉽죠.전기 신호가 들어오는 갯수를 세면 그게 곧 숫자니까요.근데 사람들은 컴퓨터에서 문자도 출력하고 싶었습니다.이번에 들어오는 전기 신호는 문자라고 치고, 신호가 65개 들어오면 그건 'A' 인걸로 하자그렇게 사람들은 특정 숫자를 문자인셈 치는 방법으로 문자 표현할 수 있었습니다.구분이 필요할 것 같아이제 코딩을 할 차례입니다.근데 우리가 65 라는 숫자를 쓰면 그게 문자 ‘A’인지, 숫자 65를 말하는지 컴퓨터가 구분할 수 없잖아요? 그래서 변수의 종류를 구분하는 방식이 탄생했습니다.// 변수는 다음과 같은 방법으로 만들 수 있습니다.// &lt;변수의 종류&gt; &lt;변수 이름&gt; = &lt;값 지정하기&gt;;int Number = 65; // 65, int는 integer, 정수를 뜻합니다.char Character = 65; // A, char는 character, 문자를 뜻합니다.// 또는char CharacterAs = 'A'; // char 종류는 문자로 직접 입력해도 됩니다.// Character 도 불러오면 'A'이고// CharacterAs 도 불러오면 'A'입니다.이런 식으로 변수의 종류가 고정되어 있는 것을 정적 프로그래밍 언어라고 합니다.정적 언어의 특징은 종류가 정해지고나면 값을 재지정할 때 종류를 변경할 수 없었습니다.int Number = 65;Number = 'A'; // 아니, 문자를 쓸 수 있는 종류가 아니야.. 오류 !!조금 불편하긴 했지만, 코드가 제대로 동작하는지를 검토하기는 편했습니다. 종류가 정해져있다면 할 수 있는 행동이 정해진 셈이기에, 컴퓨터가 개발단계에서(굳이 프로그램을 실행하지 않더라도) 오류가 발생할 것을 미리 알 수 있었죠.하지만 이건 컴퓨터에게 편한 것이지, 인간에게 편한 방식은 아니었습니다.응? 종류가 다르긴 한데 어째서..세상이 발전하면서 컴퓨터 사양이 높아지고, 점점 많은 것들을 해낼 수 있게 되면서 컴퓨터는 더 복잡한 일들을 해낼 수 있게 되었습니다. 동시에 개발자들의 고충도 커져나갔습니다.위에서 예시로 정수와 문자 두가지만 들었지만 사실 변수의 종류는 어마어마하게 많았거든요byte // 최대 255 까지만 저장할 수 있는 정수short // 최대 65536 까지만 저장할 수 있는 정수int // 꽤 긴 숫자를 저장할 수 있는 정수long // int보다 더 긴 숫자를 저장할 수 있는 정수float // 소수점 아래 몇자리까지 표현할 수 있는 소수double // 소수점 아래 더 많은 자리수를 표현할 수 있는 소수char // 문자, 'A' 같이 문자 딱 한개를 뜻합니다.String // 문자열, \"ASDFGHJK\"처럼 길이가 있는 문자입니다....이것보다 더 많은 종류가 있었고 종류가 다르면 정수와 소수점이 포함된 수를 더할 수도 없었습니다.아니 1 + 1.1 이 그렇게 어려운 문제야??  네, 적어도 컴퓨터 기준에선 그랬습니다. 종류에 대한 기준은 엄격하니까요.변수라는게 어차피 RAM에 저장된 정보일 뿐이라며?종류가 저렇게 세분화되어있던 이유는 사양이 안좋아서였습니다.같은 정수인데 왜 255, 65536 같은 최대치가 존재하냐구요? 255보다 높게 사용할게 아니라면 RAM에 공간을 적게 할당하기 위해서에요. RAM의 공간이 넉넉하지 않으니까요.근데 이제는 세상 좋아져서 컴퓨터 사양이 상향 평준화가 되었고, 저 정도 작은 정보들은 막무가내로 저장해도 될 것 같았습니다.var variable = 65; // 65, var는 variable, 변하기 쉽다는 뜻입니다.변수 종류 그거 내가 알게 뭔가?모든 종류를 대통합시킨듯한 개념이 생겼습니다.var variable = 65;variable = 'A';variable = 3.141592;variable = \"String\";variable = true;// 오류는 전혀 발생하지 않습니다뭐 어떱니까? 어차피 RAM에 저장할 뿐인데 !이제 1 + 1.1 은 2.1 입니다이것이 제가 블로그에서 자주 다루게 될 동적 프로그래밍 언어의 모양새입니다.사람에게 무척 편리하지만 당연히 컴퓨터에겐 조금 불친절한 언어이기에, 프로그램을 직접 돌려보기 전에 오류를 검토하는 것에 한계가 있습니다. 컴퓨터 입장에서는 이 변수로 숫자처럼 덧셈을 하며 다룰지, 문자열처럼 다룰지 알 수 없으니까요.그리고 결과물의 동작 효율성이 상대적으로 떨어집니다. 정적 언어일 때는 “255까지만 사용하는 숫자”라는 종류가 있었지만 지금은 그런식의 구분이 없기에, 숫자를 사용하게 된다면 long에 해당하는 큰 숫자까지 쓸 수 있게 RAM에 할당합니다.그게 자유로움이란 것 아니겠습니까적당한 합의자유롭긴 하지만 변수 종류가 정해져 있을 때는 편하게 써왔던 자동 완성 같은 기능을 쓸 수가 없게 되고, 코드를 수정할 때마다 프로그램을 빌드하는 등 편하긴 한데 뭔가 불편한 상황들을 마주하게 되어 지금은 필요에 따라서 변수의 종류를 정할 수 있는 방식으로 발전했습니다.var variable = \"ASDFG\"; // 언제든지 변할 수 있어요variable = 135;var Strict:String = \"ASDFG\"; // 이것은 문자열인 거시에요Strict = 135; // 문자열이 아니잖아요.. 오류 !그래서 동적 언어를 사용하더라도 요정도 배경은 알아두시는게 좋을 것 같았어요나눠서 쓰기엔 애매한 길이라서 긴 글이 되어버렸네요.다음 포스트에서 다시 뵐께요 😄"
  },
  
  {
    "title": "변수란 무엇인가",
    "url": "/posts/what-is-variable/",
    "categories": "정보글, 개발",
    "tags": "쉬운설명, scripting",
    "date": "2023-12-15 09:49:00 +0900",
    





    
    "snippet": "뻥이에요~거짓말 주의보이 글은 설명을 쉽게하기 위한 약간의 거짓말을 담고 있습니다.오직 이해를 쉽게 하기 위한 것이므로 진실로부터 동떨어진 거짓말까지는 아닙니다.쉬운 설명?일상에서 접하는 컴퓨터 관련 정보들을 짜집기한 식으로, 컴퓨터에 대한 관심이 없으시다면 쉽지 않을지도 몰라요.짧은 서문스크립팅을 시작하면 가장 처음에 배우는 녀석으로 보통 다음과 같...",
    "content": "뻥이에요~거짓말 주의보이 글은 설명을 쉽게하기 위한 약간의 거짓말을 담고 있습니다.오직 이해를 쉽게 하기 위한 것이므로 진실로부터 동떨어진 거짓말까지는 아닙니다.쉬운 설명?일상에서 접하는 컴퓨터 관련 정보들을 짜집기한 식으로, 컴퓨터에 대한 관심이 없으시다면 쉽지 않을지도 몰라요.짧은 서문스크립팅을 시작하면 가장 처음에 배우는 녀석으로 보통 다음과 같이 생겼습니다.var name = 'John';정보를 저장해둔 상자..데이터를 저장하기 위한 이름..등호(=) 표시는 “같다”가 아닌 “대입”이다..구체적으로 그게 무엇인지 알려주는게 아니라 “변수는 (무엇)이다” 라는 정보를 주입시키기 위해 다양한 비유와 설명이 동원됩니다만.. 정말 (무엇)일지요~이 포스트에서는 컴퓨터에서 자주 접하는 상황들과 비교하여 변수가 무엇일지 설명하려고 합니다.저장소와 파일 저장코딩과 무관해보이지만 여기서 시작하는 편이 좋을 것 같아요.여기 빈 USB가 있습니다.우리가 이 USB에 4MB 크기의 파일을 저장하면 이런 모습이 됩니다.그러고 난 다음에 3MB 크기의 파일을 저장하면 이런 모습이 되겠죠.근데 어떻게 파일 뒤에 딱 붙여서 추가되는 것일까요?이해를 돕기 위해 1MB마다 칸으로 구성된 그림을 제시해드리긴 했지만 USB 내부에 저런식으로 칸이 쳐진 것도 아닌데 말이죠.“정확히 이 자리부터 파일을 저장해야해” 라고 위치를 지정하고, 알 수 있는 걸까요?네, 있습니다.예시처럼 1MB마다는 아니지만, 저장소에는 특정 위치마다 해당하는 주소가 있습니다. 주소는 보시다시피 쓰레기값처럼 생겼어요.막 적은 듯한(실제로 막 적긴했지만) 저 주소를 입력하면 USB에서 해당하는 위치의 정보를 호출하고 저장된 내용을 불러와줍니다.우리는 이것을 파일 읽기라고 합니다.저장소의 종류하드 디스크(HDD)나 SSD 같은 저장 장치말고 이와 동일한 방식으로 처리되는 저장 장치로 RAM이 있습니다.RAM은 임시 저장 장치로 지금 실행중인 프로그램이 사용하는 정보를 잠시 저장해두었다가 프로그램이 종료될 때 삭제하는 방식으로 동작합니다.그야말로 임시 저장되는 셈이죠거의 끝났음다시 처음으로 돌아가서, 우리가 프로그램에 변수를 입력했다고 가정합시다.var name = \"John\";이것을 조금 날 것으로 풀어쓰자면RAM 주소 asli3wregtr893124k3k 에 문자열 \"John\"을 저장해두기인 것이고, 사람이 저 쓰레기값 같은 주소를 직접 관리하는 것은 불편함이 따르니,사용자가 'name'을 찾으면 그게 RAM 주소 asli3wregtr893124k3k 인 것으로 하자라고 자동으로 처리해주는 겁니다.작은 결론변수는 포인터(RAM 주소)입니다.변수는 우리가 프로그램을 실행중일 때 RAM에 올리는 위치를 말합니다."
  },
  
  {
    "title": "p5js로 시작하기 [1]",
    "url": "/posts/start-with-p5js/",
    "categories": "정보글, 개발",
    "tags": "scripting",
    "date": "2023-12-14 12:10:00 +0900",
    





    
    "snippet": "이름이 뭐 이래p5js는 Processing이라는, 시각 예술 분야에서 사용하는 프로그램의 웹 버전입니다. 특징은 언어가 쉽고, 작업 결과물이 그래픽으로 보여지기 때문에 덜 심심합니다. 코딩을 처음 시작할 때, 터미널에 나오는 글자만 보며 하는 것보단 훨씬 재미붙이기 좋을 것이라고 생각해요.무엇보다 개발 환경을 설치할 필요가 없습니다.여기서 코딩하면 ...",
    "content": "이름이 뭐 이래p5js는 Processing이라는, 시각 예술 분야에서 사용하는 프로그램의 웹 버전입니다. 특징은 언어가 쉽고, 작업 결과물이 그래픽으로 보여지기 때문에 덜 심심합니다. 코딩을 처음 시작할 때, 터미널에 나오는 글자만 보며 하는 것보단 훨씬 재미붙이기 좋을 것이라고 생각해요.무엇보다 개발 환경을 설치할 필요가 없습니다.여기서 코딩하면 됩니다.거기, 뭔가 떠 있습니다만매우 간단한 구성으로, 위에 보이는 재생 버튼을 누르면 작성된 코드를 실행하여 오른쪽에 보여줍니다. 정지를 누르면 멈춥니다.저 상태에서 바로 실행을 누르면 왼쪽에 회색 네모가 생길겁니다.400x400 픽셀 크기의, 배경색이 회색인 그림을 만드셨어요 😆프로그램의 기본 구성앞으로 다루게 될 대부분의 고수준 언어들은 다음과 같은 기본 구성을 가질 겁니다.저 스크립트에서는  setup(): 시작시 최초 1회만 실행함  draw(): 동작하는 동안 계속해서 실행함을 뜻합니다캔버스를 만드는 것은 1번만 실행하고, 배경을 회색으로 칠하는 것은 계속해서 그려대는 중이에요.물론 프로그램마다 이러한 기본 함수의 이름은 다르지만 기본적으로 시작시 최초 실행과 매 순간 반복 실행구성이 있다고 알아두시면 됩니다. 다른 조건이나 방식에 따라 실행되는 것은 전부 옵션입니다.뭔가 알듯말듯한데일단 이것저것 보면서 안목을 넓히는게 우선이라고 생각해요. 다음을 천천히 읽어봅시다.// 변수 (정보를 임시 저장)var Number = 13; // 숫자var String = \"문자열\"; // 문자var Array = [1, 2, 3]; // 배열 (Array)// 사전 (Dictionary)var json = {    key: \"value\",    13: 'number',}// 상수 (설정하면 값이 고정되어 못바꿈, 변수의 일종)const CHAR = 65;const NAME = \"John\";// 함수 (행동을 모아둔 블럭)function kind_of_act() {    const local_const = 5;    // 조건문, 만약에~ (이 조건)이라면    if (local_const &gt; Number) {        console.log('local_const 가 더 크다');    } else if (local_const &lt; Number) {        // (위 조건)이 아닌 동시에 (이 조건)이라면        console.log('Number 가 더 크다');    } else { // (위 조건)이 모두 아니라면        console.log('두 수는 같다');    }    // 조건문,     switch(Number) {        case 13:            console.log('Number는 13 입니다');            break;        default:            console.log('Number는 13이 아닙니다');            break;    }    // 반복문, 조건이 맞으면 계속 반복합니다.    while (local_const &gt; Number) {        console.log('히히 못가');    }    // 반복문, 조건이 맞으면 계속 반복합니다    // for문은 내부에 조건을 좀 더 상세하게 구성할 수 있습니다.    for (let i = 0; i &lt; 10; i++) {        console.log(i);    }    // 함수를 여기서 멈추고 0을 반환합니다.    return 0;}// 클래스 (양식, 틀)class Something {    constructor() {        this.a = 10;    }    ...}뭐라는지는 전혀 모르겠지만 새로운 단어들을 많이 접했네요.필요한 개념을 하나씩 짚어 알아보겠습니다."
  },
  
  {
    "title": "취미 개발, 쉬운 개발",
    "url": "/posts/teaching-script-easy/",
    "categories": "정보글, 개발",
    "tags": "쉬운설명",
    "date": "2023-12-11 07:43:00 +0900",
    





    
    "snippet": "고수준 언어와 취미 개발고수준 언어는 쉬워요편하게 개발할 수 있는 쉬운 언어를 고수준 언어라고 합니다.대표적으로는 파이썬이 있습니다.print('Hello World!')요즘 고수준 언어는 코드 결과물을 예측할 수 있는 가독성과 자료 관리를 용이하게 해주는 객체(Object)식 구성을 제공하여 편하게 코딩할 수 있습니다.같은 고수준 언어지만 만들어진지...",
    "content": "고수준 언어와 취미 개발고수준 언어는 쉬워요편하게 개발할 수 있는 쉬운 언어를 고수준 언어라고 합니다.대표적으로는 파이썬이 있습니다.print('Hello World!')요즘 고수준 언어는 코드 결과물을 예측할 수 있는 가독성과 자료 관리를 용이하게 해주는 객체(Object)식 구성을 제공하여 편하게 코딩할 수 있습니다.같은 고수준 언어지만 만들어진지 시간 좀 지난, 자바정도만 되어도 사용자가 알아야하는 개념이 더 많아지게 되는데class HelloWorld {    public static void main(String[] args) {        System.out.println(\"Hello World!\");     }}우… 겨우 취미로 무언가 만들겠다는데 이렇게 부담스러워서야.. !( 자바도 저수준 언어에 비하면 굉장히 편한 편입니다 😅 )취미로 개발해볼까?저는 코딩을 하면서 공식 문서를 자주 찾는 편인데, 제가 느끼기에 이건 마치 사전에서 용어찾는 것과 비슷했습니다.예를 들어, 배열 뒤에 값을 추가하는 push_back() 이라는 함수가 있다면, 어떻게 동작하는지, 어떤 인자를 필요로하는지 그 구성을 알아봅니다.배열 뒤에 값을 추가할 필요가 있을 때 말이죠.그 전까지는 push_back() 이라는 함수의 존재조차 모르고 있다가, 마치 모르는 단어를 마주하고 사전을 찾는 것처럼, 그러한 개념이 필요한 순간 참조 문서를 펼치는 것입니다.실제로 참조 문서(Reference)가 사전처럼 동작하기 때문에, 주먹구구식으로도 충분히 치고 올라갈 수 있습니다. 그 과정에서 결과물의 최적화와는 동떨어지겠지만, 초심자 기준에선 결과물의 최적화가 아닌 작업 시간의 최적화라고 볼 수 있겠습니다.주입식 K-IT교육사전을 ㄱ~ㅎ까지 전부 읽고나서 개발을 시작하는 방식 역시 존재합니다.이 방법의 목적은 한 번 읽고 전부 머리 속에 기억하려는게 아니고, 이미 있는 개념을 빠르게 활용하기 위해서지요.예를 들어, 비밀번호에 특정 문자가 들어가있는지 검토하는 부분을 만들 때 문자열을 처리하는 방식 중 하나인 정규표현식을 사용하면 빠르게 구성이 가능한데, 이 개념 자체를 모른다면 문자열 필터링하는 방식을 연구하며 시간을 허비하게 될 수 있습니다.보통 직업 육성 교육을 할 때 이런 방식을 채택합니다. 현장에서 정규표현식을 몰라서 노가다 작업이 진행되지 않도록 말이죠.대상 언어 또는 프로그램 선택하기본인이 개발과 전혀 무관하다고 생각이 드는 일을 하더라도, 전자기기가 주변에 있을 가능성이 높습니다. 21세기는 그런 세상이니까요 😃개발 언어를 배우다보면 그동안은 보이지 않았던 일상 생활 속에서 자동화가 가능한 것을, 아니면 좀 더 편하게 처리할 수 있는 것을, 그것도 아니면 그냥 더 재밋는 인생을 위한 어떤 것을 내가 만들 수 있겠노라 하게 됩니다.그렇게 하려면 이제 무엇을 공부할지 골라야겠네요.보통의 개발자라면 용처에 맞는 개발 언어가 이미 정해져 있지만,여러분이 개발을 처음 진입하는 초심자라면…게임엔진으로 내가 원하는 프로그램 개발갑작스러운 유턴에 많이 놀라신 것 같은데, 일단 읽어주세요 ^^;저는 이게 정말로 편한 방법이라고 생각하고 추천합니다.이미 겜돌이/겜순이로 게임 플레이 경험이 많다구요?정말 강력 추천합니다.독특한 목적을 띄지 않는다면예를 들어, 오픈소스 하드웨어 개발을 생각하고 초심자로 뛰어드셨다면 아마 아듀이노를 사용하게 될 것입니다.아니면 개발하려는 내용이 이미 평범한 범주를 벗어났다면 (예를 들면, 윈도우 정품 인증 문구처럼 프로그램과 무관하게 디스플레이에 뭘 띄우는 것 등), 그런 것을 해내기 위해 이미 중-저수준 언어를 찾거나 고수준 언어 중에서 그런 기능을 지원하는게 있는지 먼저 찾아봐야 할 겁니다.이처럼 개발하려는 내용이 명료하다면 보통은 개발 언어가 이미 정해져있거나 기능 검토가 필요합니다.근데 그런 독특한 경우가 아닌 보통의 경우라면, 프로그램 창이 생기고 그 위에서 어떤 행동을 하게 될 것입니다. 보통 그렇게 동작하기를 원하기도 하구요.이미 그럴 줄 알고 다 준비했지게임엔진의 장점은 이미 준비된 녀석인 점입니다.다른 언어들에서는 다양한 패키지를 떡칠해야 동작하게 될 것들을 게임엔진은 이미 기본적으로 가지고 있습니다. 대표적인 내용은 다음과 같습니다.  게임엔진에서 개발하면 게임으로서 배포할 수 있는 모든 플랫폼들, 메이저 OS(윈도우, 맥, 리눅스) 및 모바일 메이저 OS(안드로이드, iOS)에서 실행할 수 있습니다.  게임에 필요하기 때문에 이미 준비된 기능들이 많습니다. (화면에 상호작용 가능한 버튼, 파일 엑세스, 물리엔진과 객체 생성, 원한다면 3D 개체를 화면에 띄울 수도 있음)그래서 원하는 표현이나 기능을 구현하기 쉽습니다.  경험이 쌓이고 여차하면 게임을 개발하게 될 수도 있습니다.게임엔진의 이러한 장점으로 인해, 이미 게임이 아닌 미디어 아트와 같은 예술 활동에도 작품을 만들 때 게임엔진을 활용합니다.우리가 우리 편의를 위해, 예를 들어 딱히 화려할 필요 없는 문서 편집 자동화를 위해 게임엔진을 쓴다 하더라도 별로 문제될 이유가 없습니다.뭐로 가도 서울로만 가면 되니까요.물론 게임엔진의 단점도 있습니다.  실행을 위한 기본 사양이 높습니다.  레이아웃 구성 등으로 굳이 내가 이런 것까지 알아야하나? 싶은 것들을 공부하게 될 수도 있습니다. (물론 로우코딩보단 더 유연하게 동작합니다)  게임 범주를 많이 벗어난 작업을 처리하려면 다른 언어가 더 나은 경우도 있습니다. 계속 확장중이긴 하나 자유로운 범주가 게임에 맞게 한정되어 있습니다. 일단은 “게임엔진”이니까요.도망쳐추천은 추천일 뿐, 선택은 여러분의 몫이지요.저는 추천글을 마치겠습니다."
  },
  
  {
    "title": "[초심자모드] 개발을 시작하기 전에",
    "url": "/posts/before-start-scripting/",
    "categories": "정보글, 개발",
    "tags": "쉬운설명, scripting",
    "date": "2023-12-10 11:33:00 +0900",
    





    
    "snippet": "컴퓨터라면 당연히 그래야지취미 코딩, 쉬운 코딩으로 작업하는 동안 컴퓨터는 반드시 이렇게 동작할 예정입니다.  코드는 반드시 왼쪽에서 오른쪽으로, 사람이 글을 읽듯 순서대로 동작한다.  코드는 반드시 위에서 아래로, 순서대로 동작한다.  코드가 최적의 상태로 작성되어있는지 검토하고 싶다면 컴퓨터가 하는 일을 사람이 직접한다고 가정해보자.  컴퓨터는 거...",
    "content": "컴퓨터라면 당연히 그래야지취미 코딩, 쉬운 코딩으로 작업하는 동안 컴퓨터는 반드시 이렇게 동작할 예정입니다.  코드는 반드시 왼쪽에서 오른쪽으로, 사람이 글을 읽듯 순서대로 동작한다.  코드는 반드시 위에서 아래로, 순서대로 동작한다.  코드가 최적의 상태로 작성되어있는지 검토하고 싶다면 컴퓨터가 하는 일을 사람이 직접한다고 가정해보자.  컴퓨터는 거짓말을 하지 않는다. 무언가 오류가 있다면 전적으로 내가 뭘 잘못 구성한 것이다.이 규칙은 매우 편리하고 안정적이나 멀티쓰레드 코딩을 시작할 때즈음부터 어긋나기 시작합니다.겁낼 것 없습니다. 멀티쓰레드가 처음에는 정말 골치 아픈데 그 아픈 값어치를 해줍니다.어딜 감히 드라마를 가지고 와드라마에서 나왔던 개발자의 모습이 머리를 스칩니다슈슈슈슉 파파파팍- 개발 끝!이미 여기저기서 들어봤겠지만 그런 개발은 없습니다;아주 간단한 프로그램이라도, 한땀한땀 작업하는 바느질처럼 코딩 해야합니다.그러니까 작업 기간에 부담가지지 말고 천천히 시도해보세요.제 개인 작업 중에는 10년 째가 되어서야 1버전이 나온 녀석도 있었습니다.취미 좋은게 뭡니까~문서 찾기 고수이전에 제가 개발과정이 사전에서 내용을 찾는 것 같다고 말씀드렸죠.실제로 사전을 읽는 듯한 시간들이 많이 필요할 겁니다. 공식 문서가 익숙하지 않으면 포럼, 유튜브 등을 돌아다니게 될 것이지만.. 명심하세요.여러분도 어느 순간엔 공식 문서를 읽는 것에 익숙해져야 합니다.프로그래밍 언어를 개발하는 단계까지 내려갈게 아니라면, 우리는 누군가 준비한 문서를 읽을 수 있어야 합니다.그래서 문서가 익숙해지면 어떻게 되냐구요?최소한 모든 고수준 언어에 대한 부담감이 사라집니다.필요한 것은 사랑, 용기, 희망?개발할 때 중요한 것 중 하나는 끈기입니다.코드를 실행했는데 정상적으로 실행되지 않은 것은 ‘실패’가 아니라 ‘과정’입니다. 그 ‘과정’을 두려워하시지 않으셨으면 좋겠어요.개발자로 일하다보면 가끔씩 거짓말처럼 뱉게 되는 마법의 단어가 있습니다.분명 잘 동작했는데 ...검토, 재차 검토, 수차례 반복 테스트, 기타 등등 나름대로 확신을 하고 시연을 시작하면 거짓말처럼 안되는 경우도 생각보다 많아요.빨간 글자 조금 나왔다고 낙심하고 그러지 않으셨으면 좋겠습니다."
  },
  
  {
    "title": "도커에 GUI 작업 환경 구성",
    "url": "/posts/vncserver-docker/",
    "categories": "정보글, 작업환경",
    "tags": "vnc, docker",
    "date": "2023-12-09 08:40:00 +0900",
    





    
    "snippet": "가상 네트워크 컴퓨팅GUI가 필요할 것 같아..분리된 작업 환경까진 좋았지만 오직 CLI로만 작업을 해야하다보니 파일 하나 옮기는 것도 번거로워지고, 코드 서버를 통해서 작업하는 것도 한계가 있는데 이를 어찌합니까 싶으신가요?잘 오셨습니다 ^^참고로 이 글은 우분투 공식 문서를 참조하고 있으며, 공식 문서의 내용처럼 AWS와 같은 CLI 환경에서 동일...",
    "content": "가상 네트워크 컴퓨팅GUI가 필요할 것 같아..분리된 작업 환경까진 좋았지만 오직 CLI로만 작업을 해야하다보니 파일 하나 옮기는 것도 번거로워지고, 코드 서버를 통해서 작업하는 것도 한계가 있는데 이를 어찌합니까 싶으신가요?잘 오셨습니다 ^^참고로 이 글은 우분투 공식 문서를 참조하고 있으며, 공식 문서의 내용처럼 AWS와 같은 CLI 환경에서 동일하게 동작합니다.우분투 문서 원문보기근데 이거하면 뭐가 좋아요?다소 제한적이긴 하지만 원래라면 CLI로 하기 어려운 일들을 쉽게 해낼 수 있게 됩니다.예를 들면 도커에서 안드로이드 스튜디오를 실행하고, 앱 빌드 작업을 진행할 수도 있습니다.데스크탑 환경 설치하기아래 설치는 굉장히 오래 걸리고 설치 중간에 사용자가 입력해야하는 내용이 있어 그냥 기다리기만 하면 완료되지 않습니다.사용자가 입력하는 내용은 시간대, 키보드 배치 등의 정보인데 이는 리눅스 설치화면에서 나오는 내용과 동일한 것이며, 동일한 정보를 선택하여 진행하면 됩니다.apt update -y; apt upgrade -y;apt install ubuntu-desktop tightvncserver gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal -y설치가 전부 끝나고나면 vncserver를 켰다가 꺼줍니다.vncservervncserver -kill :1vncserver 설정 파일에 들어가 내용을 전부 지우고 아래와 같이 수정합니다.# 설정 파일 열기nano ~/.vnc/xstartup# ... 파일 내용 전부 삭제 후 아래 내용 붙여넣기#!/bin/shexport XKL_XMODMAP_DISABLE=1unset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESS[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid greyvncconfig -iconic &amp;gnome-panel &amp;gnome-settings-daemon &amp;metacity &amp;nautilus &amp;gnome-terminal &amp;이 후에 다시 vncserver 명령으로 켜면 VNC Viewer와 같은 앱을 통해 GUI 환경에 진입할 수 있습니다.엥? 아무 것도 안보이는데요?시작하면 파일탐색기 말고 아무것도 안보일텐데, 화면이 별도로 떠있어서 그럴 뿐 그것이 도커의 화면입니다.도커 터미널에서 CLI 행동을 하면 해당 화면에 결과가 보여집니다."
  },
  
  {
    "title": "Docker Compose 주요 속성들",
    "url": "/posts/docker-properties/",
    "categories": "정보글, 작업환경",
    "tags": "docker",
    "date": "2023-12-08 08:14:00 +0900",
    





    
    "snippet": "정보글짧게 짧게 쳐내자이 글은 빠른 정보 전달을 위해 구체적인 내용 설명을 겸하지는 않습니다.딱 이정도 선에서 설명docker-compose 사용과 관련있는 정도만 포함되어 있습니다.docker-compose.yml 파일 작성속성 설명전에 보여드린 파일을 기준으로 간단히 설명을 곁들이자면,services:  # 서비스 이름  code-server:  ...",
    "content": "정보글짧게 짧게 쳐내자이 글은 빠른 정보 전달을 위해 구체적인 내용 설명을 겸하지는 않습니다.딱 이정도 선에서 설명docker-compose 사용과 관련있는 정도만 포함되어 있습니다.docker-compose.yml 파일 작성속성 설명전에 보여드린 파일을 기준으로 간단히 설명을 곁들이자면,services:  # 서비스 이름  code-server:    # 시스템에 있거나 도커 허브에 준비된 이미지 이름    image: ubuntu    # 컨테이너 이름    container_name: code-server    # 공유폴더 정도로 생각하면 됩니다    # docker-compose.yml이 있는 myblog 폴더를 컨테이너 안에 있는 /root/myblog 폴더와 연결합니다.    volumes:      - ./myblog:/root/myblog    # 환경 변수입니다    # bash에서 export KEY = VALUE 로 지정하는 것과 동일합니다    environment: # 아래는 제 개인적인 쓰임새에 맞게 설정된 상태입니다      USER: root      DISPLAY: :1      PATH: $PATH:/root/Android/Sdk/platform-tools:/usr/local/sbin:/usr/sbin:/sbin      GODOT_SILENCE_ROOT_WARNING: 1    # 포트포워딩입니다.    # 컨테이너의 4000 포트를 컴퓨터의 4000 포트와 연결합니다.    # 이렇게 하면 네트워크에서 {컴퓨터 주소}:4000 포트로 접근했을 때 컨테이너 4000 포트로 정보가 전달됩니다.    ports:      - \"4000:4000\"      - \"5901:5901\"      - \"8080:8080\"    # 컨테이너가 시작하면 즉시 실행할 행동입니다    # tail -F /dev/null 명령 자체는 아무 것도 안하는 명령입니다. 그래서 컨테이너는 시작 후 대기 상태가 됩니다.    command: tail -F /dev/null이 정도면 docker exec -it [container_id] /bin/bash를 이용하여 가상머신처럼 가지고 놀 수 있습니다.작성 모양새대표적인 속성 정보를 입력하는 방식은# 값 (key-value 쌍)key: value# 배열 (Array)key:  - value  - value# 사전식 (Dictionary)master:  key: value  key: value조금 더 많은 정보주요 docker-compose 속성 (원문보기)"
  },
  
  {
    "title": "작업 환경 분리 구성하기 (feat. code-server)",
    "url": "/posts/code-server/",
    "categories": "정보글, 작업환경",
    "tags": "scripting, docker",
    "date": "2023-12-05 04:53:00 +0900",
    





    
    "snippet": "작업 환경 분리?시작에 앞서..코드 서버도, 도커도, 원래 이러라고 만들어진게 아니지만, 이전 포스트에 적었던 웹 브라우저 번역을 이용하고 싶어서 직접 구성한 겁니다. 불여우 브라우저로 코딩시 생기는 문제로 빈번히 브라우저가 멈추거나 하는 등의 이슈가 있으므로, 그걸 감내하면서까지 쓰고 싶은게 아니라면 글을 읽고 즐기시면 될 것 같습니다.그냥 VsCo...",
    "content": "작업 환경 분리?시작에 앞서..코드 서버도, 도커도, 원래 이러라고 만들어진게 아니지만, 이전 포스트에 적었던 웹 브라우저 번역을 이용하고 싶어서 직접 구성한 겁니다. 불여우 브라우저로 코딩시 생기는 문제로 빈번히 브라우저가 멈추거나 하는 등의 이슈가 있으므로, 그걸 감내하면서까지 쓰고 싶은게 아니라면 글을 읽고 즐기시면 될 것 같습니다.그냥 VsCode를 바로 사용하지 왜 굳이…이걸 구축할 당시에는 vscode에서 쉽고 편한 번역이 없었고, 막상 이 구성을 써보니 이 방식 나름의 이점이 있다고 생각하여 쓰고 있습니다.앞서 말씀드렸듯, 안정적인 작업환경이 중요하다면 그냥 재미로 읽어주세요 👍가상환경 구성하기가상머신이라는 개념이 생긴 후 좀 더 가벼운 형태의 가상머신 개념으로 도커가 나온 걸로 알고 있습니다. 윈도우에서는 도커 홈페이지를 통해 설치할 수 있습니다만 윈도우는 공식적으로 WSL 을 제공하고 있으니 굳이 도커를 안쓰셔도 됩니다.docker-compose 설치하기도커는 설정할 것이 꽤 많아서, 귀찮음에 설명서를 안읽고 있습니다 ^^;대신 docker-compose를 이용해 빠르게 구축하고 있어요.윈도우에서 도커 홈페이지를 통해 설치하면 docker-compose 가 같이 설치되지만 리눅스는 아닙니다. 패키지 관리자에서 docker와 docker-compose 를 둘 다 지정해줘야 합니다.이런 식으로 말이죠# 아치리눅스 패키지 설치 명령 예시sudo pacman -S docker docker-composedocker-compose 의 동작방식은 아주 간단한데, docker-compose.yml 이라는 파일이 있는 폴더에서 해당 파일 내용을 설정삼아 도커 구성을 완성시켜줍니다. 삭제도 똑같은 방식으로 진행합니다.docker-compose.yml 파일 생성하기docker-compose.yml 파일은 아래와 비슷한 방식으로 구성됩니다.services:  code-server:    image: ubuntu    container_name: code-server    volumes:      - ./myblog:/root/myblog    environment:      USER: root      DISPLAY: :1      PATH: $PATH:/root/Android/Sdk/platform-tools:/usr/local/sbin:/usr/sbin:/sbin      GODOT_SILENCE_ROOT_WARNING: 1    ports:      - \"4000:4000\"      - \"5901:5901\"      - \"8080:8080\"    command: tail -F /dev/nulldocker-compose 설정에 대해서는 나중에 다른 포스트에서 알려드릴께요, 지금은 docker-compose.yml 문서 파일을 생성하여 위 내용을 붙여넣어봅시다.docker-compose 실행하기해당 폴더에서 터미널을 열고 다음과 같이 입력하면 됩니다.docker-compose up -d그러면 위 설정(docker-compose.yml) 을 따라 컨테이너(가상환경)가 생성됩니다.컨테이너를 삭제하고 싶다면 아래 명령을 입력하면 됩니다.docker-compose down그러면 위 설정으로 생성된 모든 객체를 삭제합니다.docker-compose로 생성한 다음 yml 파일을 삭제하게 되면 docker-compose로 컨테이너를 삭제할 수 없게 되니, yml 파일을 섣불리 수정하거나 삭제하지는 말아주세요.도커 사용하기근데 도커가 생성되면 뭘 하냐구요?아무 것도 안합니다약간 거짓말을 섞자면 컨테이너를 생성했다 = 가상머신을 생성했다와 같습니다.도커는 지금…이전 내용을 가져오면,services:  code-server:    image: ubuntu    container_name: code-server    ...yml 파일에 대놓고 ubuntu라 적혀있으니 이 도커는 지금 우분투가 설치된 것을 예상할 수 있습니다. 그럼 이 우분투를 어떻게 사용하느냐..터미널에 docker ps를 입력해봅시다.&gt; docker psCONTAINER ID   IMAGE     COMMAND               CREATED        STATUS       ...fa93f0a75a94   ubuntu    \"tail -F /dev/null\"   44 hours ago   Up ...현재 활성중인 도커를 보여주는데, 컨테이너 ID(fa93f0a75a94)가 보이네요아래 명령을 입력하면 터미널로 접근할 수 있습니다.docker exec -it fa93f0a75a94 /bin/bashroot@fa93f0a75a94:/# 관리자 계정인데요?사용자가 관리자 계정이긴 하지만 이제부터는 우분투를 사용하는 것과 동일합니다.apt update -y; apt upgrade -y 를 실행한 후 이 가상머신에서 사용하고 할 것 같은 일부 기본 유틸(nano, git, wget 등)을 설치하시면 됩니다. (시작할 때 sudo가 설치되어있지 않음)code-server 설치적당히 준비가 되었으면 아래 명령어를 입력하여 코드 서버를 설치합니다.curl -fsSL https://code-server.dev/install.sh | sh드디어 코드 서버가 생겼네바로 실행해보기root@fa93f0a75a94:~# code-server......... info    - Not serving HTTPS와 실행 성공!그럼 이제 Ctrl + C 를 눌러 꺼주세요접근 설정 변경nano ~/.config/code-server/config.yaml 코드 서버 설정 파일에 접근하면 아래와 같은 내용이 준비되어 있을텐데bind-addr: 127.0.0.1:8080auth: passwordpassword: waefskgrdbf3w45egltrhalvkcert: falsebind-addr: 진입할 수 있는 주소와 포트password: 진입할 때 사용할 비밀번호일단 비밀번호만 먼저 입맛에 맞게 바꾸면 됩니다.네트워크 이야기컴퓨터 주소 중 127.0.0.1 는 네트워크에서 “나(해당 기기)“를 의미합니다.그러니까 위 설정으로는 “나“만 이 서버에 들어갈 수 있는데, 코드 서버가 도커 안에서 돌고 있고, 도커는 일종의 가상머신이므로 명백히 “나“가 아닙니다. 그건 “내 안에 있는 흑염룡“과 같은, 다른 존재이므로 저 설정으로는 접근할 수 없습니다.접근하기 위해서는 컴퓨터 기준에서 도커의 주소를 입력해주어야 합니다.도커 터미널에 net-tools를 설치하여 도커 주소를 확인해주면 됩니다.apt install net-tools... # 설치가 완료되면ifconfig보통 172.18.0.2 같은 식으로 맨 뒤가 2로 끝납니다.이제 정말 사용할 수 있나요!?!네!!"
  },
  
  {
    "title": "[Termux] 안드로이드를 리눅스처럼",
    "url": "/posts/android-termux/",
    "categories": "정보글, 작업환경",
    "tags": "android, termux",
    "date": "2023-12-04 07:01:00 +0900",
    





    
    "snippet": "터미널 에뮬레이터 앱시작하기 전에..여러분이 리눅스나 맥을 사용하며 터미널에 대한 경험이 쌓였다면 이 앱은 여러분의 스마트폰을 좀 더 스마트하게 사용할 기회를 제공합니다.아이폰이 훌륭한 물건이라는 것 정도는 저도 알지만 이러한 자유도가 좋아서 안드로이드를 못벗어나고 있습니다하하 이걸 어떻게 안써요;응? 안드로이드가 리눅스 아니었나?설명하자면 복잡합니다...",
    "content": "터미널 에뮬레이터 앱시작하기 전에..여러분이 리눅스나 맥을 사용하며 터미널에 대한 경험이 쌓였다면 이 앱은 여러분의 스마트폰을 좀 더 스마트하게 사용할 기회를 제공합니다.아이폰이 훌륭한 물건이라는 것 정도는 저도 알지만 이러한 자유도가 좋아서 안드로이드를 못벗어나고 있습니다하하 이걸 어떻게 안써요;응? 안드로이드가 리눅스 아니었나?설명하자면 복잡합니다만 약간의 거짓말을 보태어 대답하자면 아닙니다. (거짓임)가장 밑바닥에는 리눅스가 있는 것은 사실이지만 우리가 쓰는 부분은 리눅스 위에서 돌고 있는 안드로이드의 느낌으로 동작합니다.일종의 가상머신을 쓰고 있는 셈이죠.Termux 사용해보기앱 관리자 설치하기이 앱은 오픈소스입니다.안드로이드 사용자라면 플레이스토어라는 앱 관리자를 사용하고 계실텐데, 이 앱은 오픈소스 전용 앱 관리자인 F-Droid 라는 앱에서 받아야합니다.그리고 이 F-Droid 라는 앱은 플레이스토어에는 없고 *.apk 파일을 직접 다운받아 수동설치하여야 합니다.시작부터 일반적이지가 않습니다만 각오가 필요할 수준은 아닙니다.F-Droid 홈페이지로 가기Termux 설치하기플레이스토어와 모양이 다른 편입니다.검색은 우측 하단에 떠있는 버튼을 이용해주시면 됩니다termux로 검색하고 나면 다음 앱을 설치하시면 됩니다.그래서 이걸 어디에 쓴단 말이죠?쓰고 싶은 용도로 쓰시면 됩니다 (?)패키지 관리자를 통해 원하는 패키지가 있는지 확인해보고 무엇을 할 수 있을지 상상력을 발휘해보세요.termux 는 bash 파일을 실행할 수 있어서 termux에서 실행되는 범주에서 컴퓨터처럼 동작할 수 있습니다.대표적인 유용한 행위로는 다음과 같은 것들이 있습니다.  openssh 패키지를 설치하여 컴퓨터에서 무선으로 휴대폰 저장소에 접근하기          이 경우 filezilla 로 접근하면 편합니다.        컴퓨터가 없을 때에도 ssh 를 이용하여 다른 ssh 서버에 접근하기대표적인 쓸 데 없는 짓들로 다음과 같은 것들이 있습니다.  vncserver 및 gui 환경을 설치한 후 dosbox 를 설치하여 휴대폰으로 고전게임 실행하기  gui 환경을 이용하여 blender, gimp, inkscape 등 그래픽 작업 툴을 사용하기  apache2 패키지를 설치하여 유사시 걸어다니는 홈페이지 서버가 되기  android-tools 패키지를 설치한 후 무선 디버깅에 스스로(localhost) 접근하여 adb 명령어 실행시키기          다른 기기에 연결하기도 가능        htop 등 CLI 작업관리자 화면을 띄워놓고 있어보이는 척하기왜 쓸 데 없는 짓들을 더 적었는지는 묻지 마세요.알고 싶었던 것도 아니고 딱히 다 적은 것도 아닙니다…;"
  },
  
  {
    "title": "Firefox 번역 확장기능 사용",
    "url": "/posts/firefox-env/",
    "categories": "정보글, 작업환경",
    "tags": "firefox",
    "date": "2023-12-03 04:59:00 +0900",
    





    
    "snippet": "부분적 영어 문맹인시작에 앞서..웹 브라우저는 본인의 취향에 따라 마음대로 선택해도 됩니다.저도 제 취향에 대해서 이야기하는 겁니다 👍그저 번역을 말하려는게 아닙니다브라우저에 번역 확장이 준비되어 있는 것은 흔한 일입니다. 하지만 마음에 드는 번역기 모양새가 있는 경우는 많이 없지요. 이 포스트는 “번역 기능”이 아니라 “제 마음에 드는 번역기”와 그...",
    "content": "부분적 영어 문맹인시작에 앞서..웹 브라우저는 본인의 취향에 따라 마음대로 선택해도 됩니다.저도 제 취향에 대해서 이야기하는 겁니다 👍그저 번역을 말하려는게 아닙니다브라우저에 번역 확장이 준비되어 있는 것은 흔한 일입니다. 하지만 마음에 드는 번역기 모양새가 있는 경우는 많이 없지요. 이 포스트는 “번역 기능”이 아니라 “제 마음에 드는 번역기”와 그것을 이용한 저만의 편의 기능을 소개합니다.불여우 브라우저일반적으로, 불여우는 리눅스 기본 브라우저입니다. 없다면 다운받으실 수도 있습니다.브라우저를 열고 Ctrl + Shift + A 를 눌러 확장 기능 화면에 진입합니다.확장(Extensions) 탭을 눌러 검색어로 translate를 입력하면 다양한 번역기 확장이 보입니다.이 귀여운 녀석을 설치하도록 합시다.리눅스에서 설치하면 번역 대상 언어를 제대로 선택하지 못하는 경우가 있으니,Preference 페이지에서 한번 검토해보도록 합니다.번역 확장기능 사용하기번역 기능을 사용하려면 불여우 브라우저에서 글자를 블럭처리하세요.클릭-드래그, 더블 클릭, 트리플 클릭 어떤 방식으로든 블럭처리하면 번역이 진행됩니다.번역창이 근처에 작게 생성되기 때문에 고질적인 번역오류를 마주했을 때 원문과 비교하기 용이합니다.코드 서버와 함께 사용웹 브라우저에 코딩하는 환경을 구축하면 이 번역이 빛을 발하게 되는데,변수나 함수에 연결된 주석 문서를 작업 환경 내에서 번역해버리거나실행 오류와 관련된,평소라면 눈에 잘 안들어 오는 내용들을 번역하여 상황 판단을 용이하게 해주고뭐가 들어와도 다 감당할 수 있을 것 같은 용기를 줍니다.코드 서버를 구축하는 방법은 다음에 다른 포스트에서 다루도록 할께요 😄"
  },
  
  {
    "title": "일반적으로 리눅스를 설치하는 과정",
    "url": "/posts/linux-os-env/",
    "categories": "정보글, 작업환경",
    "tags": "linux",
    "date": "2023-12-02 02:32:00 +0900",
    





    
    "snippet": "작업 환경 구축 (OS)준비물16GB 이상의 빈 USB, 컴퓨터 또는 노트북, 책임감(중요함), 영어 독해력(선택사항)시작하기에 앞서..이 단계는 취향에 따라 건너뛸 수 있습니다.대부분의 오픈소스 프로그램들은 메이저 OS(윈도우, 맥, 일부 리눅스 배포판)에서 실행할 수 있으므로 이 단계를 건너뛸 수 있으나..리눅스는 무료이고, 원래 사용하는 OS를 ...",
    "content": "작업 환경 구축 (OS)준비물16GB 이상의 빈 USB, 컴퓨터 또는 노트북, 책임감(중요함), 영어 독해력(선택사항)시작하기에 앞서..이 단계는 취향에 따라 건너뛸 수 있습니다.대부분의 오픈소스 프로그램들은 메이저 OS(윈도우, 맥, 일부 리눅스 배포판)에서 실행할 수 있으므로 이 단계를 건너뛸 수 있으나..리눅스는 무료이고, 원래 사용하는 OS를 건드리지 않고 설치할 수 있으니 호기심이 생기는 정도로도 여러분은 체험할 준비가 된 셈입니다.설치하고 사용하는 과정 중 컴퓨터의 기본 구성에 대한 새로운 깨달음을 얻을 기회가 될 수도 있습니다.윈도우나 맥에 비교하면 리눅스는 날 것에 가까운 OS니까요.책임감이 중요한 이유는 오직 한가지입니다.본인이 행한 일은 본인이 책임져야 합니다. 인터넷에서 하라는대로 따라한 경우에라도 말이죠.리눅스 배포판 선택한국에서 유명한 리눅스 배포판은 우분투, 페도라 입니다.저는 아치리눅스를 추천합니다.국내 인지도나 제 추천과 무관하게, 더 많은 리눅스를 비교하고 싶다면 http://distrowatch.org/에 방문하여 랭킹을 확인해보세요.마음에 들어보인다면 공식 홈페이지에 가서 다운받고 설치하시면 됩니다.몇몇 특별한 경우가 아니라면 사용하는 것은 완벽하게 무료입니다!설치 USB 생성하기요즘은 USB에 부팅 디스크를 저장하는 방식이 다양해졌는데 저는 balenaEtcher를 사용하여 설치하는 것을 추천드립니다.USB 드라이브에 이미지를 설치할 때 USB 내용물이 포맷되므로,프로그램을 시작하기 전에 내부 파일을 다른 곳에 백업해두세요.장점은 극단적으로 쉬운 작업 과정으로, 홈페이지에 있는 이미지처럼 그냥 실행하면 됩니다.  프로그램을 다운받은 뒤  리눅스 *.iso 등 설치 이미지 파일을 선택하고  USB 드라이브를 선택한 뒤 (USB 드라이브 문자를 재차 확인해주세요)  USB 드라이브에 설치합니다.참 쉽죠?리눅스 설치하기공간 할당하기 (선택사항)이 과정은 설치 디스크에서도 할 수 있으나 그저 제가 마음 편하게 진행하기 위해 미리 진행하는 편입니다.부팅 USB가 만들어졌다면 USB를 안전하게 제거하고 시작 메뉴에 파티션으로 검색합니다.C 드라이브 용량을 얼만큼 포기하여 리눅스를 사용할지 선택합니다.최소 16GB (16384MB) 이상 할애해주는 것을 추천합니다.보통 8GB의 용량으로도 실행은 가능하지만 사용자 경험히 다소 떨어지는, 글자 그대로 ‘최소’이기 때문에 조금 여유를 주는게 좋습니다. 😧완료되었다면 컴퓨터를 종료해주세요.부팅 대상 선택이 단계는 기기 제조사마다 약간씩 다른데, 보통 F2, F8, F10, F11, F12 중에 하나로 설정되어 있습니다.전원을 켜자마자 기능키(F1~F12)를 하나씩 눌러보면서 원하는 메뉴가 뜨기를 바래봅니다.또는 화면 모퉁이에 Boot menu(F11) 이런식으로 적혀있기도 합니다.운이 나빠서 다른 메뉴에 들어갔다면 다음의 방법 중 하나를 시도하세요.  당황스럽지만 천천히 내용을 읽어보고 해당 설정 메뉴에서 탈출합니다.  전원 버튼을 눌러봅니다. 보통 바로 꺼지는데, 그렇지 않다면 5초간 길게 눌러 강제종료합니다.여러분이 찾아야하는건 부팅 순서를 고르는 메뉴입니다.일반적으로 USB가 하드디스크보다 부팅 우선순위가 밀리기 때문에 우리가 USB로 부팅할 것이라고 선택해주어야 합니다.설치하기USB로 부팅하면 보통 'Try ~'로 시작하는 메뉴가 준비되어 있습니다.해당 리눅스를 설치하기 전에 미리 사용해보고, 설치를 원한다면 내장되어있는 설치 파일을 통해 진행합니다.OS 설치는 마치 프로그램을 설치하듯 다음 &gt; 다음 &gt; 다음 &gt; 다음 &gt; ... &gt; 완료 방식으로 진행하게 되긴 하는데, 읽어보지도 않고 '다음'을 눌러 넘기는 그 행동에 책임지실 수 있다면 읽지 않고 '다음'만 눌러 설치하셔도 되긴 합니다..리눅스를 처음 설치하는거라면 시간을 들여 설치 프로그램이 무엇을 이야기하고 설정하는지 읽어보는 것을 추천합니다.별거 아닌 내용 같지만, OS 수준에서 처음에 어떤 정보를 사용자에게 요청하는지를 알아두는 것은 컴퓨터쪽 감각을 키우는데 도움이 됩니다.그리고 오픈소스 프로그램들을 접할 때에도 거의 동일합니다.공식 홈페이지나 문서를 천천히 읽어주세요.어떤 경험이 처음이라면, 부디 읽어보세요. 제발."
  },
  
  {
    "title": "[Jekyll] 홈 화면에 포스트가 안보일 때",
    "url": "/posts/post-not-show/",
    "categories": "정보글",
    "tags": "jekyll",
    "date": "2023-12-01 17:18:00 +0900",
    





    
    "snippet": "Home 에 최근 포스트가 보이지 않는 문제일부 지킬 테마 중 준비된 스타터 템플릿을 사용하여 시작할 때 홈 페이지에서 최신 포스트가 보여지지 않는 문제가 발생할 수 있다.이 경우 포스트 상단 설정(Front matter)에---pin: true---위 설정을 추가해주면 강제로 핀 처리가 되어 홈 페이지에 게시가 되는데 이것은 Pinned 게시물이기 ...",
    "content": "Home 에 최근 포스트가 보이지 않는 문제일부 지킬 테마 중 준비된 스타터 템플릿을 사용하여 시작할 때 홈 페이지에서 최신 포스트가 보여지지 않는 문제가 발생할 수 있다.이 경우 포스트 상단 설정(Front matter)에---pin: true---위 설정을 추가해주면 강제로 핀 처리가 되어 홈 페이지에 게시가 되는데 이것은 Pinned 게시물이기 때문에 핀 표시가 남게 된다이 방법이 임시방편이 될 수 있으나 이 후 모든 포스트마다 핀 처리를 해야하고, 실제로 핀 처리를 해야할 때는 핀 기능을 쓸 수 없게 되는 셈이 된다.해결방법프로젝트 폴더에 index 파일이 중첩된 경우 이런 문제가 발생할 수 있다....index.htmlindex.md (markdown)...기본값은 index.md를 가져와 _site/index.html 파일을 생성하는데프로젝트 폴더 내 *.html 파일 역시 파일 생성에 참조하므로 index.html 파일 생성에 index.md와 index.html 두 파일이 처리되어 문제가 된다.index.md 파일의 내용물을 index.html 에 병합하고 index.md 파일을 삭제하면 정상적으로 최근 포스트 기록이 홈 화면에 표시된다프로젝트를 생성한지 얼마 안되었다면 위 사진과 같이 사실상 같은 내용물로 구성되어있을 것이다.index.md 파일을 삭제하도록 하자 :)원문 링크"
  },
  
  {
    "title": "블로그 생성됨",
    "url": "/posts/init/",
    "categories": "",
    "tags": "helloworld, jekyll",
    "date": "2023-11-30 10:28:42 +0900",
    





    
    "snippet": "세상아 안녕!",
    "content": "세상아 안녕!"
  }
  
]

